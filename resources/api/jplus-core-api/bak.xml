<?xml version='1.0' encoding='utf-8'?>
<?xml-stylesheet type='text/xsl' href='assets/styles/default.xsl'?>

<docs version="1.4">
  <cat value="核心">
    <subcat value="DOM 核心函数">
      <function name="JPlus" return="JPlus">
        <desc>这个函数接收一个包含 CSS 选择器的字符串，然后用这个字符串去匹配一组元素。</desc>
        <longdesc>JPlus 的核心功能都是通过这个函数实现的。 JPlus中的一切都基于这个函数，或者说都是在以某种方式使用这个函数。这个函数最基本的用法就是向它传递一个表达式（通常由 CSS 选择器组成），然后根据这个表达式来查找所有匹配的元素。

默认情况下, 如果没有指定context参数，$()将在当前的 HTML document中查找 DOM 元素；如果指定了 context 参数，如一个 DOM 元素集或 JPlus 对象，那就会在这个 context 中查找。在JPlus 1.3.2以后，其返回的元素顺序等同于在context中出现的先后顺序。

参考文档中 选择器 部分获取更多用于 expression 参数的 CSS 语法的信息。</longdesc>
        <params name="expression" type="String">
          <desc>用来查找的字符串</desc>
        </params>
        <params name="context" type="Element, JPlus" optional="true">
          <desc>作为待查找的 DOM 元素集、文档或 JPlus 对象。</desc>
        </params>
        <example>
          <desc>找到所有 p 元素，并且这些元素都必须是 div 元素的子元素。</desc>
          <html>&lt;p&gt;one&lt;/p&gt; &lt;div&gt;&lt;p&gt;two&lt;/p&gt;&lt;/div&gt; &lt;p&gt;three&lt;/p&gt;</html>
          <code>$("div &gt; p");</code>
          <result>[ &lt;p&gt;two&lt;/p&gt; ]</result>
        </example>
        <example>
          <desc>在文档的第一个表单中，查找所有的单选按钮(即: type 值为 radio 的 input 元素)。</desc>
          <code>$("input:radio", document.forms[0]);</code>
        </example>
        <example>
          <desc>在一个由 AJAX 返回的 XML 文档中，查找所有的 div 元素。</desc>
          <code>$("div", xml.responseXML);</code>
        </example>
      </function>
      <function name="JPlus" return="JPlus">
        <desc>根据提供的原始 HTML 标记字符串，动态创建由 JPlus 对象包装的 DOM 元素。</desc>
        <longdesc>你可以传递一个手写的 HTML 字符串，或者由某些模板引擎或插件创建的字符串，也可以是通过 AJAX 加载过来的字符串。但是在你创建 input 元素的时会有限制，可以参考第二个示例。当然这个字符串可以包含斜杠 (比如一个图像地址)，还有反斜杠。当你创建单个元素时，请使用闭合标签或 XHTML 格式。例如，创建一个 span ，可以用 <![CDATA[$("&lt;span/&gt;") 或 $("&lt;span&gt;&lt;/span&gt;") ，但不推荐 $("&lt;span&gt;")。]]>在JPlus 中，这个语法等同于$(document.createElement("span")) 。</longdesc>
        <params name="html" type="String">
          <desc>用于动态创建DOM元素的HTML标记字符串</desc>
        </params>
        <params name="ownerDocument" type="Document" optional="true">
          <desc>创建DOM元素所在的文档</desc>
        </params>
        <example>
          <desc>动态创建一个 div 元素（以及其中的所有内容），并将它追加到 body 元素中。在这个函数的内部，是通过临时创建一个元素，并将这个元素的 innerHTML 属性设置为给定的标记字符串，来实现标记到 DOM 元素转换的。所以，这个函数既有灵活性，也有局限性。</desc>
          <code>$("&lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;").appendTo("body");</code>
        </example>
        <example>
          <desc>创建一个 &lt;input&gt; 元素必须同时设定 type 属性。因为微软规定 &lt;input&gt; 元素的 type 只能写一次。</desc>
          <code>// 在 IE 中无效:
$("&lt;input&gt;").attr("type", "checkbox");
// 在 IE 中有效:
$("&lt;input type='checkbox'&gt;");</code>
        </example>
      </function>
      <function name="JPlus" return="JPlus">
        <desc>根据提供的原始 HTML 标记字符串，动态创建由 JPlus 对象包装的 DOM 元素。同时设置一系列的属性、事件等。</desc>
        <params name="html" type="String">
          <desc>用于动态创建DOM元素的HTML标记字符串</desc>
        </params>
        <params name="props" type="Map">
          <desc>用于附加到新创建元素上的属性、事件和方法</desc>
        </params>
        <example>
          <desc>动态创建一个 div 元素（以及其中的所有内容），并将它追加到 body 元素中。在这个函数的内部，是通过临时创建一个元素，并将这个元素的 innerHTML 属性设置为给定的标记字符串，来实现标记到 DOM 元素转换的。所以，这个函数既有灵活性，也有局限性。</desc>
          <code><![CDATA[$("<div>", {
  "class": "test",
  text: "Click me!",
  click: function(){
    $(this).toggleClass("test");
  }
}).appendTo("body");]]></code>
        </example>
        <example>
          <desc>创建一个 &lt;input&gt; 元素，同时设定 type 属性、属性值，以及一些事件。</desc>
          <code><![CDATA[$("<input>", {
  type: "text",
  val: "Test",
  focusin: function() {
    $(this).addClass("active");
  },
  focusout: function() {
    $(this).removeClass("active");
  }
}).appendTo("form");]]></code>
        </example>
      </function>
      <function name="JPlus" return="JPlus">
        <desc>将一个或多个DOM元素转化为JPlus对象。</desc>
        <longdesc>这个函数也可以接收XML文档和Window对象（虽然它们不是DOM元素）作为有效的参数。</longdesc>
        <params name="elements" type="Element, Array&lt;Element&gt;">
          <desc>用于封装成JPlus对象的DOM元素</desc>
        </params>
        <example>
          <desc>设置页面背景色。</desc>
          <code>$(document.body).css( "background", "black" );</code>
        </example>
        <example>
          <desc>隐藏一个表单中所有元素。</desc>
          <code>$(myForm.elements).hide()</code>
        </example>
      </function>
      <function name="JPlus" return="JPlus">
        <desc>返回一个空的JPlus对象。</desc>
        <longdesc>JPlus 1.4中，如果不提供任何参数，则返回一个空JPlus对象。在先前版本中，这会返回一个包含document节点的对象。</longdesc>
      </function>
      <function name="JPlus" return="JPlus">
        <desc>$(document).ready()的简写。</desc>
        <longdesc>允许你绑定一个在DOM文档载入完成后执行的函数。这个函数的作用如同$(document).ready()一样，只不过用这个函数时，需要把页面中所有需要在 DOM 加载完成时执行的$()操作符都包装到其中来。从技术上来说，这个函数是可链接的－－但真正以这种方式链接的情况并不多。

你可以在一个页面中使用任意多个$(document).ready事件。参考 ready(Function) 获取更多 ready 事件的信息。</longdesc>
        <params name="callback" type="Function">
          <desc>当DOM加载完成后要执行的函数</desc>
        </params>
        <example>
          <desc>当DOM加载完成后，执行其中的函数。</desc>
          <code>$(function(){
  // 文档就绪
});</code>
        </example>
        <example>
          <desc>使用 $(document).ready() 的简写，同时内部的 JPlus 代码依然使用 $ 作为别名，而不管全局的 $ 为何。</desc>
          <code>JPlus(function($) {
  // 你可以在这里继续使用$作为别名...
});</code>
        </example>
      </function>
    </subcat>
    <subcat value="JPlus 对象访问">
      <function name="each" return="JPlus">
        <desc>以每一个匹配的元素作为上下文来执行一个函数。</desc>
        <longdesc>意味着，每次执行传递进来的函数时，函数中的this关键字都指向一个不同的DOM元素（每次都是一个不同的匹配元素）。而且，在每次执行函数时，都会给函数传递一个表示作为执行环境的元素在匹配的元素集合中所处位置的数字值作为参数（从零开始的整型）。 返回 'false' 将停止循环 (就像在普通的循环中使用 'break')。返回 'true' 跳至下一个循环(就像在普通的循环中使用'continue')。</longdesc>
        <params name="callback" type="Function">
          <desc>对于每个匹配的元素所要执行的函数</desc>
        </params>
        <example>
          <desc>迭代两个图像，并设置它们的 src 属性。注意:此处 this 指代的是 DOM 对象而非 JPlus 对象。</desc>
          <html>&lt;img/&gt;&lt;img/&gt;</html>
          <code>$("img").each(function(i){
   this.src = "test" + i + ".jpg";
 });</code>
          <result>[ &lt;img src="test0.jpg" /&gt;, &lt;img src="test1.jpg" /&gt; ]</result>
        </example>
        <example>
          <desc>如果你想得到 JPlus对象，可以使用 $(this) 函数。</desc>
          <html>&lt;button&gt;Change colors&lt;/button&gt;
&lt;span&gt;&lt;/span&gt; 
&lt;div&gt;&lt;/div&gt; 
&lt;div&gt;&lt;/div&gt;

&lt;div&gt;&lt;/div&gt; 
&lt;div&gt;&lt;/div&gt;
&lt;div id="stop"&gt;Stop here&lt;/div&gt; 
&lt;div&gt;&lt;/div&gt;

&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;</html>
          <code>$("img").each(function(){
  $(this).toggleClass("example");
});</code>
        </example>
        <example>
          <desc>你可以使用 'return' 来提前跳出 each() 循环。</desc>
          <html>&lt;button&gt;Change colors&lt;/button&gt;
&lt;span&gt;&lt;/span&gt; 
&lt;div&gt;&lt;/div&gt; 
&lt;div&gt;&lt;/div&gt;

&lt;div&gt;&lt;/div&gt; 
&lt;div&gt;&lt;/div&gt;
&lt;div id="stop"&gt;Stop here&lt;/div&gt; 
&lt;div&gt;&lt;/div&gt;

&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;</html>
          <code>$("button").click(function () { 
$("div").each(function (index, domEle) { 
  // domEle == this 
  $(domEle).css("backgroundColor", "yellow");  
  if ($(this).is("#stop")) { 
  $("span").text("Stopped at div index #" + index); 
  return false; 
  } 
});
});</code>
        </example>
      </function>
      <function name="size" return="Number">
        <desc>JPlus 对象中元素的个数。</desc>
        <longdesc>这个函数的返回值与 JPlus 对象的'&lt;span title="Core/length"&gt;length&lt;/span&gt;' 属性一致。</longdesc>
        <example>
          <desc>计算文档中所有图片数量</desc>
          <html>&lt;img src="test1.jpg"/&gt; &lt;img src="test2.jpg"/&gt;</html>
          <code>$("img").size();</code>
          <result>2</result>
        </example>
      </function>
      <property name="length" return="Number">
        <desc>JPlus 对象中元素的个数。</desc>
        <longdesc>当前匹配的元素个数。 &lt;span title="Core/size"&gt;size&lt;/span&gt; 将返回相同的值。</longdesc>
        <example>
          <desc>计算文档中所有图片数量</desc>
          <html>&lt;img src="test1.jpg"/&gt; &lt;img src="test2.jpg"/&gt;</html>
          <code>$("img").length;</code>
          <result>2</result>
        </example>
      </property>
      <property name="selector" return="Striing">
        <desc>JPlus 1.3新增。返回传给JPlus()的原始选择器。</desc>
        <longdesc>换句话说，就是返回你用什么选择器来找到这个元素的。可以与&lt;span title="Core/context"&gt;context&lt;/span&gt;一起使用，用于精确检测选择器查询情况。这两个属性对插件开发人员很有用。</longdesc>
        <example>
          <desc>确定查询的选择器</desc>
          <code>$("ul")
  .append("&lt;li&gt;" + $("ul").selector + "&lt;/li&gt;")
  .append("&lt;li&gt;" + $("ul li").selector + "&lt;/li&gt;")
  .append("&lt;li&gt;" + $("div#foo ul:not([class])").selector + "&lt;/li&gt;");</code>
          <result>ul
ul li
div#foo ul:not([class])</result>
        </example>
      </property>
      <property name="context" return="Element">
        <desc>JPlus 1.3新增。返回传给JPlus()的原始的DOM节点内容，即JPlus()的第二个参数。如果没有指定，那么context指向当前的文档(document)。</desc>
        <longdesc>可以与&lt;span title="Core/selector"&gt;selector&lt;/span&gt;一起使用，用于精确检测选择器查询情况。这两个属性对插件开发人员很有用。</longdesc>
        <example>
          <desc>检测使用的文档内容</desc>
          <code>$("ul")
  .append("&lt;li&gt;" + $("ul").context + "&lt;/li&gt;")
  .append("&lt;li&gt;" + $("ul", document.body).context.nodeName + "&lt;/li&gt;");</code>
          <result>[object HTMLDocument]  //如果是IE浏览器，则返回[object]
BODY</result>
        </example>
      </property>
      <function name="get" return="Array&lt;Element>">
        <desc>取得所有匹配的 DOM 元素集合。</desc>
        <longdesc>这是取得所有匹配元素的一种向后兼容的方式（不同于JPlus对象，而实际上是元素数组）。

如果你想要直接操作 DOM 对象而不是 JPlus 对象，这个函数非常有用。</longdesc>
        <example>
          <desc>选择文档中所有图像作为元素数组，并用数组内建的 reverse 方法将数组反向。</desc>
          <html>&lt;img src="test1.jpg"/&gt; &lt;img src="test2.jpg"/&gt;</html>
          <code>$("img").get().reverse();</code>
          <result>[ &lt;img src="test2.jpg"/&gt; &lt;img src="test1.jpg"/&gt; ]</result>
        </example>
      </function>
      <function name="get" return="Element">
        <desc>取得其中一个匹配的元素。 num表示取得第几个匹配的元素。</desc>
        <longdesc>这能够让你选择一个实际的DOM 元素并且对他直接操作，而不是通过 JPlus 函数。$(this).get(0)与$(this)[0]等价。</longdesc>
        <params name="index" type="Number">
          <desc>取得第 index 个位置上的元素</desc>
        </params>
        <example>
          <desc></desc>
          <html>&lt;img src="test1.jpg"/&gt; &lt;img src="test2.jpg"/&gt;</html>
          <code>$("img").get(0);</code>
          <result>[ &lt;img src="test1.jpg"/&gt; ]</result>
        </example>
      </function>
      <function name="index" return="Number">
        <desc>搜索匹配的元素，并返回相应元素的索引值，从0开始计数。</desc>
        <longdesc>如果不给 .index() 方法传递参数，那么返回值就是这个JPlus对象集合中第一个元素相对于其同辈元素的位置。
		
			如果参数是一组DOM元素或者JPlus对象，那么返回值就是传递的元素相对于原先集合的位置。
		
		如果参数是一个选择器，那么返回值就是原先元素相对于选择器匹配元素中的位置。如果找不到匹配的元素，则返回-1。
		
		具体请参考示例。
		</longdesc>
        <params name="subject" type="Selector,Element" optional="true">
          <desc>要搜索的对象</desc>
        </params>
        <example>
          <desc>查找元素的索引值</desc>
          <html>&lt;ul&gt;
  &lt;li id=&quot;foo&quot;&gt;foo&lt;/li&gt;
  &lt;li id=&quot;bar&quot;&gt;bar&lt;/li&gt;
  &lt;li id=&quot;baz&quot;&gt;baz&lt;/li&gt;
&lt;/ul&gt;</html>
          <code>$('li').index(document.getElementById('bar')); //1，传递一个DOM对象，返回这个对象在原先集合中的索引位置
$('li').index($('#bar')); //1，传递一个JPlus对象
$('li').index($('li:gt(0)')); //1，传递一组JPlus对象，返回这个对象中第一个元素在原先集合中的索引位置
$('#bar').index('li'); //1，传递一个选择器，返回#bar在所有li中的做引位置
$('#bar').index(); //1，不传递参数，返回这个元素在同辈中的索引位置。
		  </code>
        </example>
      </function>
    </subcat>
    <subcat value="数据缓存">
      <function name="data" return="Any">
        <desc>返回元素上储存的相应名字的数据，可以用data(name, value)来设定。</desc>
        <longdesc>如果JPlus集合指向多个元素，那将只返回第一个元素的对应数据。

这个函数可以用于在一个元素上存取数据而避免了循环引用的风险。JPlus.data是1.2.3版的新功能。你可以在很多地方使用这个函数，另外JPlus UI里经常使用这个函数。

如果不带任何参数，则会把所有数据作为一个JavaScript对象来返回。</longdesc>
        <params name="name" type="String" optional="true">
          <desc>存储的数据名</desc>
        </params>
        <example>
          <desc>在一个div上存取数据</desc>
          <html>&lt;div&gt;&lt;/div&gt;</html>
          <code>$("div").data("blah");  // undefined
$("div").data("blah", "hello");  // blah设置为hello
$("div").data("blah");  // hello
$("div").data("blah", 86);  // 设置为86
$("div").data("blah");  //  86
$("div").removeData("blah");  //移除blah
$("div").data("blah");  // undefined</code>
        </example>
        <example>
          <desc>在一个div上存取名/值对数据</desc>
          <html>&lt;div&gt;&lt;/div&gt;</html>
          <code>$("div").data("test", { first: 16, last: "pizza!" });
$("div").data("test").first  //16;
$("div").data("test").last  //pizza!;</code>
        </example>
      </function>
      <function name="data" return="JPlus">
        <desc>在元素上存放数据,返回JPlus对象。</desc>
        <longdesc>如果JPlus集合指向多个元素，那将在所有元素上设置对应数据。

这个函数不用建立一个新的expando，就能在一个元素上存放任何格式的数据，而不仅仅是字符串。</longdesc>
        <params name="name" type="String">
          <desc>存储的数据名</desc>
        </params>
        <params name="value" type="Any">
          <desc>将要存储的任意数据</desc>
        </params>
        <example>
          <desc>参考data(name)的示例</desc>
        </example>
      </function>
      <function name="data" return="JPlus">
        <desc>在元素上存放一组数据，返回JPlus对象。</desc>
        <longdesc>注意，如果使用这个方法之后，原先存放的所有数据都会被重写！因为这些数据，包括事件处理函数，都是绑定在元素上的。所以以一个obj作为参数使用 .data()方法时，请务必小心！</longdesc>
        <params name="obj" type="Object">
          <desc>一个用于设置数据的键/值对</desc>
        </params>
        <example>
          <desc>参考data(name)的示例</desc>
        </example>
      </function>
      <function name="removeData" return="JPlus">
        <desc>在元素上移除存放的数据</desc>
        <longdesc>与$(...).data(name, value)函数作用相反</longdesc>
        <params name="name" type="String">
          <desc>存储的数据名</desc>
        </params>
        <example>
          <desc>参考data(name)的示例</desc>
        </example>
      </function>
      <function name="JPlus.data" return="JPlus">
        <desc>在元素上存放数据,返回JPlus对象。</desc>
        <longdesc>注意：这是一个底层方法。你应当使用.data()来代替。</longdesc>
        <params name="element" type="String">
          <desc>要关联数据的DOM对象</desc>
        </params>
        <params name="key" type="String">
          <desc>存储的数据名</desc>
        </params>
        <params name="value" type="Any">
          <desc>将要存储的任意数据</desc>
        </params>
        <example>
          <code>JPlus.data(document.body, 'foo', 52);
JPlus.data(document.body, 'bar', 'test');</code>
        </example>
      </function>
      <function name="JPlus.data" return="Object">
        <desc>查询在元素上存放的数据</desc>
        <longdesc>如果不指定参数，则会返回元素上面存放的所有数据，以Object的形式返回。
		
注意：这是一个底层方法。你应当使用.data()来代替。</longdesc>
        <params name="element" type="String" optional="true">
          <desc>要查询数据的DOM对象</desc>
        </params>
        <params name="key" type="String" optional="true">
          <desc>存储的数据名</desc>
        </params>
        <example>
          <code>alert(JPlus.data( document.body, 'foo' );
alert(JPlus.data( document.body ));</code>
        </example>
      </function>
    </subcat>
    <subcat value="队列控制">
      <function name="queue" return="Array&lt;Function>">
        <desc>返回指向第一个匹配元素的队列(将是一个函数数组)</desc>
        <params name="name" type="String">
          <desc>队列名，默认为fx</desc>
        </params>
        <example>
          <desc>显示队列长度</desc>
          <html>&lt;style&gt;
  div { margin:3px; width:40px; height:40px;
        position:absolute; left:0px; top:30px; 
        background:green; display:none; }
  div.newcolor { background:blue; }
  span { color:red; }
  &lt;/style&gt;
  &lt;button id="show"&gt;Show Length of Queue&lt;/button&gt;
  &lt;span&gt;&lt;/span&gt;
  &lt;div&gt;&lt;/div&gt;</html>
          <code>$("#show").click(function () {
      var n = $("div").queue("fx");
      $("span").text("Queue length is: " + n.length);
});
function runIt() {
      $("div").show("slow");
      $("div").animate({left:'+=200'},2000);
      $("div").slideToggle(1000);
      $("div").slideToggle("fast");
      $("div").animate({left:'-=200'},1500);
      $("div").hide("slow");
      $("div").show(1200);
      $("div").slideUp("normal", runIt);
}
runIt();</code>
        </example>
      </function>
      <function name="queue" return="JPlus">
        <desc>在匹配的元素的队列最后添加一个函数</desc>
        <params name="name" type="String">
          <desc>队列名，默认为fx</desc>
        </params>
        <params name="callback" type="Function">
          <desc>要添加进队列的函数</desc>
        </params>
        <example>
          <desc>插入一个自定义函数
如果函数执行后要继续队列，则执行 JPlus(this).dequeue();</desc>
          <html>&lt;style&gt;
  div { margin:3px; width:40px; height:40px;
        position:absolute; left:0px; top:30px; 
        background:green; display:none; }
  div.newcolor { background:blue; }
  &lt;/style&gt;
  Click here...
  &lt;div&gt;&lt;/div&gt;</html>
          <code>$(document.body).click(function () {
      $("div").show("slow");
      $("div").animate({left:'+=200'},2000);
      $("div").queue(function () {
          $(this).addClass("newcolor");
          $(this).dequeue();
      });
      $("div").animate({left:'-=200'},500);
      $("div").queue(function () {
          $(this).removeClass("newcolor");
          $(this).dequeue();
      });
      $("div").slideUp();
});</code>
        </example>
      </function>
      <function name="queue" return="JPlus">
        <desc>将匹配元素的队列用新的一个队列来代替(函数数组).</desc>
        <params name="name" type="String">
          <desc>队列名，默认为fx</desc>
        </params>
        <params name="queue" type="Array&lt;Function&gt;">
          <desc>用于替换的队列。所有函数都有同一个参数，这个值与queue(callback)相同</desc>
        </params>
        <example>
          <desc>通过设定队列数组来删除动画队列</desc>
          <html>&lt;style&gt;
  div { margin:3px; width:40px; height:40px;
        position:absolute; left:0px; top:30px; 
        background:green; display:none; }
  div.newcolor { background:blue; }
  &lt;/style&gt;

  &lt;button id="start"&gt;Start&lt;/button&gt;
  &lt;button id="stop"&gt;Stop&lt;/button&gt;
  &lt;div&gt;&lt;/div&gt;</html>
          <code>$("#start").click(function () {
      $("div").show("slow");
      $("div").animate({left:'+=200'},5000);
      $("div").queue(function () {
          $(this).addClass("newcolor");
          $(this).dequeue();
      });
      $("div").animate({left:'-=200'},1500);
      $("div").queue(function () {
          $(this).removeClass("newcolor");
          $(this).dequeue();
      });
      $("div").slideUp();
  });
  $("#stop").click(function () {
      $("div").queue("fx", []);
      $("div").stop();
  });</code>
        </example>
      </function>
      <function name="dequeue" return="JPlus">
        <desc>从队列最前端移除一个队列函数，并执行他。</desc>
        <params name="name" type="String">
          <desc>队列名，默认为fx</desc>
        </params>
        <example>
          <desc>用dequeue来结束自定义队列函数，并让队列继续进行下去。</desc>
          <html>&lt;style&gt;
  div { margin:3px; width:50px; position:absolute;
        height:50px; left:10px; top:30px; 
        background-color:yellow; }
  div.red { background-color:red; }
  &lt;/style&gt;

  &lt;button&gt;Start&lt;/button&gt;
  &lt;div&gt;&lt;/div&gt;</html>
          <code>$("button").click(function () {
      $("div").animate({left:'+=200px'}, 2000);
      $("div").animate({top:'0px'}, 600);
      $("div").queue(function () {
          $(this).toggleClass("red");
          $(this).dequeue();
      });
      $("div").animate({left:'10px', top:'30px'}, 700);
  });</code>
        </example>
      </function>
      <function name="clearQueue" return="JPlus">
        <desc>JPlus 1.4 新增。清空对象上尚未执行的所有队列</desc>
        <longdesc>如果不带参数，则默认清空的是动画队列。这跟stop(true)类似，但stop()只能清空动画队列，而这个可以清空所有通过 .queue() 创建的队列。</longdesc>
        <params name="queueName" type="Boolean" optional="true">
          <desc>含有队列名的字符串。默认是"Fx"，动画队列。</desc>
        </params>
      </function>
    </subcat>
    <subcat value="插件机制">
      <function name="JPlus.fn.extend" return="JPlus">
        <desc>扩展 JPlus 元素集来提供新的方法（通常用来制作插件）。</desc>
        <longdesc>查看这里&lt;a href="http://docs.jquery.com/Plugins/Authoring" title="Plugins/Authoring"&gt;Plugins/Authoring&lt;/a&gt;可以获取更多信息。</longdesc>
        <params name="object" type="Object">
          <desc>用来扩充 JPlus 对象。</desc>
        </params>
        <example>
          <desc>增加两个插件方法。</desc>
          <code>JPlus.fn.extend({
  check: function() {
    return this.each(function() { this.checked = true; });
  },
  uncheck: function() {
    return this.each(function() { this.checked = false; });
  }
});</code>
          <result>$("input[type=checkbox]").check();
$("input[type=radio]").uncheck();</result>
        </example>
      </function>
      <function name="JPlus.extend" return="JPlus">
        <desc>扩展JPlus对象本身。</desc>
        <longdesc>用来在JPlus命名空间上增加新函数。 查看 &lt;span title="Core/JPlus.fn.extend"&gt;'JPlus.fn.extend'&lt;/span&gt; 获取更多添加&lt;a href="http://docs.jquery.com/Plugins/Authoring" title="Plugins/Authoring"&gt;插件&lt;/a&gt;的信息。</longdesc>
        <params name="object" type="Object">
          <desc>用以扩展 JPlus 对象</desc>
        </params>
        <example>
          <desc>在JPlus命名空间上增加两个函数。</desc>
          <code>JPlus.extend({
  min: function(a, b) { return a &lt; b ? a : b; },
  max: function(a, b) { return a &gt; b ? a : b; }
});</code>
          <result>JPlus.min(2,3); // =&gt; 2
JPlus.max(4,5); // =&gt; 5</result>
        </example>
      </function>
    </subcat>
    <subcat value="多库共存">
      <function name="JPlus.noConflict" return="JPlus">
        <desc>运行这个函数将变量$的控制权让渡给第一个实现它的那个库。</desc>
        <longdesc>这有助于确保JPlus不会与其他库的$对象发生冲突。

在运行这个函数后，就只能使用JPlus变量访问JPlus对象。例如，在要用到$("div p")的地方，就必须换成JPlus("div p")。

'''注意:'''这个函数必须在你导入JPlus文件之后，并且在导入另一个导致冲突的库'''之前'''使用。当然也应当在其他冲突的库被使用之前，除非JPlus是最后一个导入的。</longdesc>
        <example>
          <desc>将$引用的对象映射回原始的对象。</desc>
          <code>JPlus.noConflict();
// 使用 JPlus
JPlus("div p").hide();
// 使用其他库的 $()
$("content").style.display = 'none';</code>
        </example>
        <example>
          <desc>恢复使用别名$，然后创建并执行一个函数，在这个函数的作用域中仍然将$作为JPlus的别名来使用。在这个函数中，原来的$对象是无效的。这个函数对于大多数不依赖于其他库的插件都十分有效。</desc>
          <code>JPlus.noConflict();
(function($) { 
  $(function() {
    // 使用 $ 作为 JPlus 别名的代码
  });
})(JPlus);
// 其他用 $ 作为别名的库的代码</code>
        </example>
        <example>
          <desc>创建一个新的别名用以在接下来的库中使用JPlus对象。</desc>
          <code>var j = JPlus.noConflict();
// 基于 JPlus 的代码
j("div p").hide();
// 基于其他库的 $() 代码
$("content").style.display = 'none';</code>
        </example>
      </function>
      <function name="JPlus.noConflict" return="JPlus">
        <desc>将$和JPlus的控制权都交还给原来的库。用之前请考虑清楚!</desc>
        <longdesc>这是相对于简单的 '''noConflict''' 方法更极端的版本，因为这将完全重新定义JPlus。这通常用于一种极端的情况，比如你想要将JPlus嵌入一个高度冲突的环境。'''注意:'''调用此方法后极有可能导致插件失效。</longdesc>
        <params name="extreme" type="Boolean">
          <desc>传入 true 来允许彻底将JPlus变量还原</desc>
        </params>
        <example>
          <desc>完全将 JPlus 移到一个新的命名空间。</desc>
          <code>var dom = {};
dom.query = JPlus.noConflict(true);</code>
          <result>// 新 JPlus 的代码
dom.query("div p").hide();
// 另一个库 $() 的代码
$("content").style.display = 'none';
// 另一个版本 JPlus 的代码
JPlus("div &gt; p").hide();</result>
        </example>
      </function>
    </subcat>
  </cat>
  <cat value="选择器">
    <subcat value="基本">
      <selector name="id" return="Array&lt;Element>">
        <sample>#id</sample>
        <desc>根据给定的ID匹配一个元素。</desc>
        <longdesc>如果选择器中包含特殊字符，可以用两个斜杠转义。参见示例。</longdesc>
        <params name="id" type="String">
          <desc>用于搜索的，通过元素的 id 属性中给定的值</desc>
        </params>
        <example>
          <desc>查找 ID 为"myDiv"的元素。</desc>
          <html>&lt;div id="notMe"&gt;&lt;p&gt;id="notMe"&lt;/p&gt;&lt;/div&gt;
&lt;div id="myDiv"&gt;id="myDiv"&lt;/div&gt;</html>
          <code>$("#myDiv");</code>
          <result>[ &lt;div id="myDiv"&gt;id="myDiv"&lt;/div&gt; ]</result>
        </example>
        <example>
          <desc>查找含有特殊字符的元素</desc>
          <html>&lt;span id="foo:bar"&gt;&lt;/span&gt;
&lt;span id="foo[bar]"&gt;&lt;/span&gt;
&lt;span id="foo.bar"&gt;&lt;/span&gt;</html>
          <code>#foo\\:bar
#foo\\[bar\\]
#foo\\.bar</code>
        </example>
      </selector>
      <selector name="element" return="Array&lt;Element(s)>">
        <sample>element</sample>
        <desc>根据给定的元素名匹配所有元素</desc>
        <params name="element" type="String">
          <desc>一个用于搜索的元素。指向 DOM 节点的标签名。</desc>
        </params>
        <example>
          <desc>查找一个 DIV 元素。</desc>
          <html>&lt;div&gt;DIV1&lt;/div&gt;
&lt;div&gt;DIV2&lt;/div&gt;
&lt;span&gt;SPAN&lt;/span&gt;</html>
          <code>$("div");</code>
          <result>[ &lt;div&gt;DIV1&lt;/div&gt;, &lt;div&gt;DIV2&lt;/div&gt; ]</result>
        </example>
      </selector>
      <selector name="class" return="Array&lt;Element(s)>">
        <sample>.class</sample>
        <desc>根据给定的类匹配元素。</desc>
        <params name="class" type="String">
          <desc>一个用以搜索的类。一个元素可以有多个类，只要有一个符合就能被匹配到。</desc>
        </params>
        <example>
          <desc>查找所有类是 "myClass" 的元素.</desc>
          <html>&lt;div class="notMe"&gt;div class="notMe"&lt;/div&gt;
&lt;div class="myClass"&gt;div class="myClass"&lt;/div&gt;
&lt;span class="myClass"&gt;span class="myClass"&lt;/span&gt;</html>
          <code>$(".myClass");</code>
          <result>[ &lt;div class="myClass"&gt;div class="myClass"&lt;/div&gt;, &lt;span class="myClass"&gt;span class="myClass"&lt;/span&gt; ]</result>
        </example>
      </selector>
      <selector name="all" return="Array&lt;Element(s)>">
        <sample>*</sample>
        <desc>匹配所有元素</desc>
        <longdesc>多用于结合上下文来搜索。</longdesc>
        <example>
          <desc>找到每一个元素</desc>
          <html>&lt;div&gt;DIV&lt;/div&gt;
&lt;span&gt;SPAN&lt;/span&gt;
&lt;p&gt;P&lt;/p&gt;</html>
          <code>$("*")</code>
          <result>[ &lt;div&gt;DIV&lt;/div&gt;, &lt;span&gt;SPAN&lt;/span&gt;, &lt;p&gt;P&lt;/p&gt; ]</result>
        </example>
      </selector>
      <selector name="multiple" return="Array&lt;Element(s)>">
        <sample>selector1,selector2,selectorN</sample>
        <desc>将每一个选择器匹配到的元素合并后一起返回。</desc>
        <longdesc>你可以指定任意多个选择器，并将匹配到的元素合并到一个结果内。</longdesc>
        <params name="selector1" type="Selector">
          <desc>一个有效的选择器</desc>
        </params>
        <params name="selector2" type="Selector">
          <desc>另一个有效的选择器</desc>
        </params>
        <params name="selectorN" type="Selector" optional="true">
          <desc>任意多个有效选择器</desc>
        </params>
        <example>
          <desc>找到匹配任意一个类的元素。</desc>
          <html>&lt;div&gt;div&lt;/div&gt;
&lt;p class="myClass"&gt;p class="myClass"&lt;/p&gt;
&lt;span&gt;span&lt;/span&gt;
&lt;p class="notMyClass"&gt;p class="notMyClass"&lt;/p&gt;</html>
          <code>$("div,span,p.myClass")</code>
          <result>[ &lt;div&gt;div&lt;/div&gt;, &lt;p class="myClass"&gt;p class="myClass"&lt;/p&gt;, &lt;span&gt;span&lt;/span&gt; ]</result>
        </example>
      </selector>
    </subcat>
    <subcat value="层级">
      <selector name="descendant" return="Array&lt;Element(s)>">
        <sample>ancestor descendant</sample>
        <desc>在给定的祖先元素下匹配所有的后代元素</desc>
        <params name="ancestor" type="Selector">
          <desc>任何有效选择器</desc>
        </params>
        <params name="descendant" type="Selector">
          <desc>用以匹配元素的选择器，并且它是第一个选择器的后代元素</desc>
        </params>
        <example>
          <desc>找到表单中所有的 input 元素</desc>
          <html>&lt;form&gt;
  &lt;label&gt;Name:&lt;/label&gt;
  &lt;input name="name" /&gt;
  &lt;fieldset&gt;
      &lt;label&gt;Newsletter:&lt;/label&gt;
      &lt;input name="newsletter" /&gt;
 &lt;/fieldset&gt;
&lt;/form&gt;
&lt;input name="none" /&gt;</html>
          <code>$("form input")</code>
          <result>[ &lt;input name="name" /&gt;, &lt;input name="newsletter" /&gt; ]</result>
        </example>
      </selector>
      <selector name="child" return="Array&lt;Element(s)>">
        <sample>parent &gt; child</sample>
        <desc>在给定的父元素下匹配所有的子元素</desc>
        <params name="parent" type="Selector">
          <desc>任何有效选择器</desc>
        </params>
        <params name="child" type="Selector">
          <desc>用以匹配元素的选择器，并且它是第一个选择器的子元素</desc>
        </params>
        <example>
          <desc>匹配表单中所有的子级input元素。</desc>
          <html>&lt;form&gt;
  &lt;label&gt;Name:&lt;/label&gt;
  &lt;input name="name" /&gt;
  &lt;fieldset&gt;
      &lt;label&gt;Newsletter:&lt;/label&gt;
      &lt;input name="newsletter" /&gt;
 &lt;/fieldset&gt;
&lt;/form&gt;
&lt;input name="none" /&gt;</html>
          <code>$("form &gt; input")</code>
          <result>[ &lt;input name="name" /&gt; ]</result>
        </example>
      </selector>
      <selector name="next" return="Array&lt;Element(s)>">
        <sample>prev + next</sample>
        <desc>匹配所有紧接在 prev 元素后的 next 元素</desc>
        <params name="prev" type="Selector">
          <desc>任何有效选择器</desc>
        </params>
        <params name="next" type="Selector">
          <desc>一个有效选择器并且紧接着第一个选择器</desc>
        </params>
        <example>
          <desc>匹配所有跟在 label 后面的 input 元素</desc>
          <html>&lt;form&gt;
  &lt;label&gt;Name:&lt;/label&gt;
  &lt;input name="name" /&gt;
  &lt;fieldset&gt;
      &lt;label&gt;Newsletter:&lt;/label&gt;
      &lt;input name="newsletter" /&gt;
 &lt;/fieldset&gt;
&lt;/form&gt;
&lt;input name="none" /&gt;</html>
          <code>$("label + input")</code>
          <result>[ &lt;input name="name" /&gt;, &lt;input name="newsletter" /&gt; ]</result>
        </example>
      </selector>
      <selector name="siblings" return="Array&lt;Element(s)>">
        <sample>prev ~ siblings</sample>
        <desc>匹配 prev 元素之后的所有 siblings 元素</desc>
        <params name="prev" type="Selector">
          <desc>任何有效选择器</desc>
        </params>
        <params name="siblings" type="Selector">
          <desc>一个选择器，并且它作为第一个选择器的同辈</desc>
        </params>
        <example>
          <desc>找到所有与表单同辈的 input 元素</desc>
          <html>&lt;form&gt;
  &lt;label&gt;Name:&lt;/label&gt;
  &lt;input name="name" /&gt;
  &lt;fieldset&gt;
      &lt;label&gt;Newsletter:&lt;/label&gt;
      &lt;input name="newsletter" /&gt;
 &lt;/fieldset&gt;
&lt;/form&gt;
&lt;input name="none" /&gt;</html>
          <code>$("form ~ input")</code>
          <result>[ &lt;input name="none" /&gt; ]</result>
        </example>
      </selector>
    </subcat>
    <subcat value="简单">
      <selector name="first" return="Array&lt;Element>">
        <sample>:first</sample>
        <desc>匹配找到的第一个元素</desc>
        <example>
          <desc>查找表格的第一行</desc>
          <html>&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;Header 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</html>
          <code>$("tr:first")</code>
          <result>[ &lt;tr&gt;&lt;td&gt;Header 1&lt;/td&gt;&lt;/tr&gt; ]</result>
        </example>
      </selector>
      <selector name="last" return="Array&lt;Element>">
        <sample>:last</sample>
        <desc>匹配找到的最后一个元素</desc>
        <example>
          <desc>查找表格的最后一行</desc>
          <html>&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;Header 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</html>
          <code>$("tr:last")</code>
          <result>[ &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt; ]</result>
        </example>
      </selector>
      <selector name="not" return="Array&lt;Element(s)>">
        <sample>:not</sample>
        <desc>去除所有与给定选择器匹配的元素</desc>
        <longdesc>在JPlus 1.3中，已经支持复杂选择器了（例如:not(div a) 和 :not(div,a)）</longdesc>
        <params name="selector" type="Selector">
          <desc>用于筛选的选择器</desc>
        </params>
        <example>
          <desc>查找所有未选中的 input 元素</desc>
          <html>&lt;input name="apple" /&gt;
&lt;input name="flower" checked="checked" /&gt;</html>
          <code>$("input:not(:checked)")</code>
          <result>[ &lt;input name="apple" /&gt; ]</result>
        </example>
      </selector>
      <selector name="even" return="Array&lt;Element(s)>">
        <sample>:even</sample>
        <desc>匹配所有索引值为偶数的元素，从 0 开始计数</desc>
        <example>
          <desc>查找表格的1、3、5...行（即索引值0、2、4...）</desc>
          <html>&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;Header 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</html>
          <code>$("tr:even")</code>
          <result>[ &lt;tr&gt;&lt;td&gt;Header 1&lt;/td&gt;&lt;/tr&gt;, &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt; ]</result>
        </example>
      </selector>
      <selector name="odd" return="Array&lt;Element(s)>">
        <sample>:odd</sample>
        <desc>匹配所有索引值为奇数的元素，从 0 开始计数</desc>
        <example>
          <desc>查找表格的2、4、6行（即索引值1、3、5...）</desc>
          <html>&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;Header 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</html>
          <code>$("tr:odd")</code>
          <result>[ &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt; ]</result>
        </example>
      </selector>
      <selector name="eq" return="Array&lt;Element>">
        <sample>:eq</sample>
        <desc>匹配一个给定索引值的元素</desc>
        <params name="index" type="Number">
          <desc>从 0 开始计数</desc>
        </params>
        <example>
          <desc>查找第二行</desc>
          <html>&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;Header 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</html>
          <code>$("tr:eq(1)")</code>
          <result>[ &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt; ]</result>
        </example>
      </selector>
      <selector name="gt" return="Array&lt;Element(s)>">
        <sample>:gt</sample>
        <desc>匹配所有大于给定索引值的元素</desc>
        <params name="index" type="Number">
          <desc>从 0 开始计数</desc>
        </params>
        <example>
          <desc>查找第二第三行，即索引值是1和2，也就是比0大</desc>
          <html>&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;Header 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</html>
          <code>$("tr:gt(0)")</code>
          <result>[ &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt;, &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt; ]</result>
        </example>
      </selector>
      <selector name="lt" return="Array&lt;Element(s)>">
        <sample>:lt</sample>
        <desc>匹配所有小于给定索引值的元素</desc>
        <params name="index" type="Number">
          <desc>从 0 开始计数</desc>
        </params>
        <example>
          <desc>查找第一第二行，即索引值是0和1，也就是比2小</desc>
          <html>&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;Header 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</html>
          <code>$("tr:lt(2)")</code>
          <result>[ &lt;tr&gt;&lt;td&gt;Header 1&lt;/td&gt;&lt;/tr&gt;, &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt; ]</result>
        </example>
      </selector>
      <selector name="header" return="Array&lt;Element(s)>">
        <sample>:header</sample>
        <desc>匹配如 h1, h2, h3之类的标题元素</desc>
        <example>
          <desc>给页面内所有标题加上背景色</desc>
          <html>&lt;h1&gt;Header 1&lt;/h1&gt;
&lt;p&gt;Contents 1&lt;/p&gt;
&lt;h2&gt;Header 2&lt;/h2&gt;
&lt;p&gt;Contents 2&lt;/p&gt;</html>
          <code>$(":header").css("background", "#EEE");</code>
          <result>[ &lt;h1 style="background:#EEE;"&gt;Header 1&lt;/h1&gt;, &lt;h2 style="background:#EEE;"&gt;Header 2&lt;/h2&gt; ]</result>
        </example>
      </selector>
      <selector name="animated" return="Array&lt;Element(s)>">
        <sample>:animated</sample>
        <desc>匹配所有正在执行动画效果的元素</desc>
        <example>
          <desc>只有对不在执行动画效果的元素执行一个动画特效</desc>
          <html>&lt;button id="run"&gt;Run&lt;/button&gt;&lt;div&gt;&lt;/div&gt;</html>
          <code>$("#run").click(function(){
  $("div:not(:animated)").animate({ left: "+=20" }, 1000);
});</code>
        </example>
      </selector>
    </subcat>
    <subcat value="内容">
      <selector name="contains" return="Array&lt;Element(s)>">
        <sample>:contains</sample>
        <desc>匹配包含给定文本的元素</desc>
        <params name="text" type="String">
          <desc>一个用以查找的字符串</desc>
        </params>
        <example>
          <desc>查找所有包含 "John" 的 div 元素</desc>
          <html>&lt;div&gt;John Resig&lt;/div&gt;
&lt;div&gt;George Martin&lt;/div&gt;
&lt;div&gt;Malcom John Sinclair&lt;/div&gt;
&lt;div&gt;J. Ohn</html>
          <code>$("div:contains('John')")</code>
          <result>[ &lt;div&gt;John Resig&lt;/div&gt;, &lt;div&gt;Malcom John Sinclair&lt;/div&gt; ]</result>
        </example>
      </selector>
      <selector name="empty" return="Array&lt;Element(s)>">
        <sample>:empty</sample>
        <desc>匹配所有不包含子元素或者文本的空元素</desc>
        <example>
          <desc>查找所有不包含子元素或者文本的空元素</desc>
          <html>&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</html>
          <code>$("td:empty")</code>
          <result>[ &lt;td&gt;&lt;/td&gt;, &lt;td&gt;&lt;/td&gt; ]</result>
        </example>
      </selector>
      <selector name="has" return="Array&lt;Element(s)>">
        <sample>:has</sample>
        <desc>匹配含有选择器所匹配的元素的元素</desc>
        <params name="selector" type="Selector">
          <desc>一个用于筛选的选择器</desc>
        </params>
        <example>
          <desc>给所有包含 p 元素的 div 元素添加一个 text 类</desc>
          <html>&lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;
&lt;div&gt;Hello again!&lt;/div&gt;</html>
          <code>$("div:has(p)").addClass("test");</code>
          <result>[ &lt;div class="test"&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt; ]</result>
        </example>
      </selector>
      <selector name="parent" return="Array&lt;Element(s)>">
        <sample>:parent</sample>
        <desc>匹配含有子元素或者文本的元素</desc>
        <example>
          <desc>查找所有含有子元素或者文本的 td 元素</desc>
          <html>&lt;table&gt;
  &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</html>
          <code>$("td:parent")</code>
          <result>[ &lt;td&gt;Value 1&lt;/td&gt;, &lt;td&gt;Value 2&lt;/td&gt; ]</result>
        </example>
      </selector>
    </subcat>
    <subcat value="可见性">
      <selector name="hidden" return="Array&lt;Element(s)>">
        <sample>:hidden</sample>
        <desc>匹配所有的不可见元素，input 元素的 type 属性为 "hidden" 的话也会被匹配到</desc>
        <example>
          <desc>查找所有不可见的 tr 元素</desc>
          <html>&lt;table&gt;
  &lt;tr style="display:none"&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</html>
          <code>$("tr:hidden")</code>
          <result>[ &lt;tr style="display:none"&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt; ]</result>
        </example>
      </selector>
      <selector name="visible" return="Array&lt;Element(s)>">
        <sample>:visible</sample>
        <desc>匹配所有的可见元素</desc>
        <example>
          <desc>查找所有可见的 tr 元素</desc>
          <html>&lt;table&gt;
  &lt;tr style="display:none"&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</html>
          <code>$("tr:visible")</code>
          <result>[ &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt; ]</result>
        </example>
      </selector>
    </subcat>
    <subcat value="属性">
      <selector name="attributeHas" return="Array&lt;Element(s)>">
        <sample>[attribute]</sample>
        <desc>匹配包含给定属性的元素。注意，在JPlus 1.3中，前导的@符号已经被废除！如果想要兼容最新版本，只需要简单去掉@符号即可。</desc>
        <params name="attribute" type="String">
          <desc>属性名</desc>
        </params>
        <example>
          <desc>查找所有含有 id 属性的 div 元素</desc>
          <html>&lt;div&gt;
  &lt;p&gt;Hello!&lt;/p&gt;
&lt;/div&gt;
&lt;div id="test2"&gt;&lt;/div&gt;</html>
          <code>$("div[id]")</code>
          <result>[ &lt;div id="test2"&gt;&lt;/div&gt; ]</result>
        </example>
      </selector>
      <selector name="attributeEquals" return="Array&lt;Element(s)>">
        <sample>[attribute=value]</sample>
        <desc>匹配给定的属性是某个特定值的元素</desc>
        <params name="attribute" type="String">
          <desc>属性名</desc>
        </params>
        <params name="value" type="String" optional="true">
          <desc>属性值。引号在大多数情况下是可选的。但在遇到诸如属性值包含"]"时，用以避免冲突。</desc>
        </params>
        <example>
          <desc>查找所有 name 属性是 newsletter 的 input 元素</desc>
          <html>&lt;input type="checkbox" name="newsletter" value="Hot Fuzz" /&gt;
&lt;input type="checkbox" name="newsletter" value="Cold Fusion" /&gt;
&lt;input type="checkbox" name="accept" value="Evil Plans" /&gt;</html>
          <code>$("input[name='newsletter']").attr("checked", true);</code>
          <result>[ &lt;input type="checkbox" name="newsletter" value="Hot Fuzz" checked="true" /&gt;, &lt;input type="checkbox" name="newsletter" value="Cold Fusion" checked="true" /&gt; ]</result>
        </example>
      </selector>
      <selector name="attributeNotEqual" return="Array&lt;Element(s)>">
        <sample>[attribute!=value]</sample>
        <desc>匹配所有不含有指定的属性，或者属性不等于特定值的元素。</desc>
        <longdesc>此选择器等价于:not([attr=value])&lt;br&gt;要匹配含有特定属性但不等于特定值的元素，请使用[attr]:not([attr=value])</longdesc>
        <params name="attribute" type="String">
          <desc>属性名</desc>
        </params>
        <params name="value" type="String" optional="true">
          <desc>属性值。引号在大多数情况下是可选的。但在遇到诸如属性值包含"]"时，用以避免冲突。</desc>
        </params>
        <example>
          <desc>查找所有 name 属性不是 newsletter 的 input 元素</desc>
          <html>&lt;input type="checkbox" name="newsletter" value="Hot Fuzz" /&gt;
&lt;input type="checkbox" name="newsletter" value="Cold Fusion" /&gt;
&lt;input type="checkbox" name="accept" value="Evil Plans" /&gt;</html>
          <code>$("input[name!='newsletter']").attr("checked", true);</code>
          <result>[ &lt;input type="checkbox" name="accept" value="Evil Plans" checked="true" /&gt; ]</result>
        </example>
      </selector>
      <selector name="attributeStartsWith" return="Array&lt;Element(s)>">
        <sample>[attribute^=value]</sample>
        <desc>匹配给定的属性是以某些值开始的元素</desc>
        <params name="attribute" type="String">
          <desc>属性名</desc>
        </params>
        <params name="value" type="String" optional="true">
          <desc>属性值。引号在大多数情况下是可选的。但在遇到诸如属性值包含"]"时，用以避免冲突。</desc>
        </params>
        <example>
          <desc>查找所有 name 以 'news' 开始的 input 元素</desc>
          <html>&lt;input name="newsletter" /&gt;
&lt;input name="milkman" /&gt;
&lt;input name="newsboy" /&gt;</html>
          <code>$("input[name^='news']")</code>
          <result>[ &lt;input name="newsletter" /&gt;, &lt;input name="newsboy" /&gt; ]</result>
        </example>
      </selector>
      <selector name="attributeEndsWith" return="Array&lt;Element(s)>">
        <sample>[attribute$=value]</sample>
        <desc>匹配给定的属性是以某些值结尾的元素</desc>
        <params name="attribute" type="String">
          <desc>属性名</desc>
        </params>
        <params name="value" type="String" optional="true">
          <desc>属性值。引号在大多数情况下是可选的。但在遇到诸如属性值包含"]"时，用以避免冲突。</desc>
        </params>
        <example>
          <desc>查找所有 name 以 'letter' 结尾的 input 元素</desc>
          <html>&lt;input name="newsletter" /&gt;
&lt;input name="milkman" /&gt;
&lt;input name="jobletter" /&gt;</html>
          <code>$("input[name$='letter']")</code>
          <result>[ &lt;input name="newsletter" /&gt;, &lt;input name="jobletter" /&gt; ]</result>
        </example>
      </selector>
      <selector name="attributeContains" return="Array&lt;Element(s)>">
        <sample>[attribute*=value]</sample>
        <desc>匹配给定的属性是以包含某些值的元素</desc>
        <params name="attribute" type="String">
          <desc>属性名</desc>
        </params>
        <params name="value" type="String" optional="true">
          <desc>属性值。引号在大多数情况下是可选的。但在遇到诸如属性值包含"]"时，用以避免冲突。</desc>
        </params>
        <example>
          <desc>查找所有 name 包含 'man' 的 input 元素</desc>
          <html>&lt;input name="man-news" /&gt;
&lt;input name="milkman" /&gt;
&lt;input name="letterman2" /&gt;
&lt;input name="newmilk" /&gt;</html>
          <code>$("input[name*='man']")</code>
          <result>[ &lt;input name="man-news" /&gt;, &lt;input name="milkman" /&gt;, &lt;input name="letterman2" /&gt; ]</result>
        </example>
      </selector>
      <selector name="attributeMultiple" return="Array&lt;Element(s)>">
        <sample>[selector1][selector2][selectorN]</sample>
        <desc>复合属性选择器，需要同时满足多个条件时使用。</desc>
        <params name="selector1" type="Selector">
          <desc>属性选择器</desc>
        </params>
        <params name="selector2" type="Selector">
          <desc>另一个属性选择器，用以进一步缩小范围</desc>
        </params>
        <params name="selectorN" type="Selector">
          <desc>任意多个属性选择器</desc>
        </params>
        <example>
          <desc>找到所有含有 id 属性，并且它的 name 属性是以 man 结尾的</desc>
          <html>&lt;input id="man-news" name="man-news" /&gt;
&lt;input name="milkman" /&gt;
&lt;input id="letterman" name="new-letterman" /&gt;
&lt;input name="newmilk" /&gt;</html>
          <code>$("input[id][name$='man']")</code>
          <result>[ &lt;input id="letterman" name="new-letterman" /&gt; ]</result>
        </example>
      </selector>
    </subcat>
    <subcat value="子元素">
      <selector name="nthChild" return="Array&lt;Element(s)>">
        <sample>:nth-child</sample>
        <desc>匹配其父元素下的第N个子或奇偶元素</desc>
        <longdesc>':eq(index)' 只匹配一个元素，而这个将为每一个父元素匹配子元素。:nth-child从1开始的，而:eq()是从0算起的！可以使用:&lt;br&gt;nth-child(even)&lt;br&gt;:nth-child(odd)&lt;br&gt;:nth-child(3n)&lt;br&gt;:nth-child(2)&lt;br&gt;:nth-child(3n+1)&lt;br&gt;:nth-child(3n+2)</longdesc>
        <params name="index" type="Number">
          <desc>要匹配元素的序号，从1开始</desc>
        </params>
        <example>
          <desc>在每个 ul 查找第 2 个li</desc>
          <html>&lt;ul&gt;
  &lt;li&gt;John&lt;/li&gt;
  &lt;li&gt;Karl&lt;/li&gt;
  &lt;li&gt;Brandon&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
  &lt;li&gt;Glen&lt;/li&gt;
  &lt;li&gt;Tane&lt;/li&gt;
  &lt;li&gt;Ralph&lt;/li&gt;
&lt;/ul&gt;</html>
          <code>$("ul li:nth-child(2)")</code>
          <result>[ &lt;li&gt;Karl&lt;/li&gt;,   &lt;li&gt;Tane&lt;/li&gt; ]</result>
        </example>
      </selector>
      <selector name="firstChild" return="Array&lt;Element(s)>">
        <sample>:first-child</sample>
        <desc>匹配第一个子元素</desc>
        <longdesc>':first' 只匹配一个元素，而此选择符将为每个父元素匹配一个子元素</longdesc>
        <example>
          <desc>在每个 ul 中查找第一个 li</desc>
          <html>&lt;ul&gt;
  &lt;li&gt;John&lt;/li&gt;
  &lt;li&gt;Karl&lt;/li&gt;
  &lt;li&gt;Brandon&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
  &lt;li&gt;Glen&lt;/li&gt;
  &lt;li&gt;Tane&lt;/li&gt;
  &lt;li&gt;Ralph&lt;/li&gt;
&lt;/ul&gt;</html>
          <code>$("ul li:first-child")</code>
          <result>[ &lt;li&gt;John&lt;/li&gt;, &lt;li&gt;Glen&lt;/li&gt; ]</result>
        </example>
      </selector>
      <selector name="lastChild" return="Array&lt;Element(s)>">
        <sample>:last-child</sample>
        <desc>匹配最后一个子元素</desc>
        <longdesc>':last'只匹配一个元素，而此选择符将为每个父元素匹配一个子元素</longdesc>
        <example>
          <desc>在每个 ul 中查找最后一个 li</desc>
          <html>&lt;ul&gt;
  &lt;li&gt;John&lt;/li&gt;
  &lt;li&gt;Karl&lt;/li&gt;
  &lt;li&gt;Brandon&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
  &lt;li&gt;Glen&lt;/li&gt;
  &lt;li&gt;Tane&lt;/li&gt;
  &lt;li&gt;Ralph&lt;/li&gt;
&lt;/ul&gt;</html>
          <code>$("ul li:last-child")</code>
          <result>[ &lt;li&gt;Brandon&lt;/li&gt;, &lt;li&gt;Ralph&lt;/li&gt; ]</result>
        </example>
      </selector>
      <selector name="onlyChild" return="Array&lt;Element(s)>">
        <sample>:only-child</sample>
        <desc>如果某个元素是父元素中唯一的子元素，那将会被匹配</desc>
        <longdesc>如果父元素中含有其他元素，那将不会被匹配。</longdesc>
        <example>
          <desc>在 ul 中查找是唯一子元素的 li</desc>
          <html>&lt;ul&gt;
  &lt;li&gt;John&lt;/li&gt;
  &lt;li&gt;Karl&lt;/li&gt;
  &lt;li&gt;Brandon&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
  &lt;li&gt;Glen&lt;/li&gt;
&lt;/ul&gt;</html>
          <code>$("ul li:only-child")</code>
          <result>[ &lt;li&gt;Glen&lt;/li&gt; ]</result>
        </example>
      </selector>
    </subcat>
    <subcat value="表单">
      <selector name="input" return="Array&lt;Element(s)>">
        <sample>:input</sample>
        <desc>匹配所有 input, textarea, select 和 button 元素</desc>
        <example>
          <desc>查找所有的input元素，下面这些元素都会被匹配到。</desc>
          <html>&lt;form&gt;
    &lt;input type=&quot;button&quot; value=&quot;Input Button&quot;/&gt;
    &lt;input type=&quot;checkbox&quot; /&gt;

    &lt;input type=&quot;file&quot; /&gt;
    &lt;input type=&quot;hidden&quot; /&gt;
    &lt;input type=&quot;image&quot; /&gt;

    &lt;input type=&quot;password&quot; /&gt;
    &lt;input type=&quot;radio&quot; /&gt;
    &lt;input type=&quot;reset&quot; /&gt;

    &lt;input type=&quot;submit&quot; /&gt;
    &lt;input type=&quot;text&quot; /&gt;
    &lt;select&gt;&lt;option&gt;Option&lt;/option&gt;&lt;/select&gt;

    &lt;textarea&gt;&lt;/textarea&gt;
    &lt;button&gt;Button&lt;/button&gt;

&lt;/form&gt;</html>
          <code>$(":input")</code>
          <result>[ 
    &lt;input type=&quot;button&quot; value=&quot;Input Button&quot;/&gt;,
    &lt;input type=&quot;checkbox&quot; /&gt;,

    &lt;input type=&quot;file&quot; /&gt;,
    &lt;input type=&quot;hidden&quot; /&gt;,
    &lt;input type=&quot;image&quot; /&gt;,

    &lt;input type=&quot;password&quot; /&gt;,
    &lt;input type=&quot;radio&quot; /&gt;,
    &lt;input type=&quot;reset&quot; /&gt;,

    &lt;input type=&quot;submit&quot; /&gt;,
    &lt;input type=&quot;text&quot; /&gt;,
    &lt;select&gt;&lt;option&gt;Option&lt;/option&gt;&lt;/select&gt;,

    &lt;textarea&gt;&lt;/textarea&gt;,
    &lt;button&gt;Button&lt;/button&gt;,
 ]</result>
        </example>
      </selector>
      <selector name="text" return="Array&lt;Element(s)>">
        <sample>:text</sample>
        <desc>匹配所有的单行文本框</desc>
        <example>
          <desc>查找所有文本框</desc>
          <html>&lt;form&gt;
  &lt;input type="text" /&gt;
  &lt;input type="checkbox" /&gt;
  &lt;input type="radio" /&gt;
  &lt;input type="image" /&gt;
  &lt;input type="file" /&gt;
  &lt;input type="submit" /&gt;
  &lt;input type="reset" /&gt;
  &lt;input type="password" /&gt;
  &lt;input type="button" /&gt;
  &lt;select&gt;&lt;option/&gt;&lt;/select&gt;
  &lt;textarea&gt;&lt;/textarea&gt;
  &lt;button&gt;&lt;/button&gt;
&lt;/form&gt;</html>
          <code>$(":text")</code>
          <result>[ &lt;input type="text" /&gt; ]</result>
        </example>
      </selector>
      <selector name="password" return="Array&lt;Element(s)>">
        <sample>:password</sample>
        <desc>匹配所有密码框</desc>
        <example>
          <desc>查找所有密码框</desc>
          <html>&lt;form&gt;
  &lt;input type="text" /&gt;
  &lt;input type="checkbox" /&gt;
  &lt;input type="radio" /&gt;
  &lt;input type="image" /&gt;
  &lt;input type="file" /&gt;
  &lt;input type="submit" /&gt;
  &lt;input type="reset" /&gt;
  &lt;input type="password" /&gt;
  &lt;input type="button" /&gt;
  &lt;select&gt;&lt;option/&gt;&lt;/select&gt;
  &lt;textarea&gt;&lt;/textarea&gt;
  &lt;button&gt;&lt;/button&gt;
&lt;/form&gt;</html>
          <code>$(":password")</code>
          <result>[ &lt;input type="password" /&gt; ]</result>
        </example>
      </selector>
      <selector name="radio" return="Array&lt;Element(s)>">
        <sample>:radio</sample>
        <desc>匹配所有单选按钮</desc>
        <example>
          <desc>查找所有单选按钮</desc>
          <html>&lt;form&gt;
  &lt;input type="text" /&gt;
  &lt;input type="checkbox" /&gt;
  &lt;input type="radio" /&gt;
  &lt;input type="image" /&gt;
  &lt;input type="file" /&gt;
  &lt;input type="submit" /&gt;
  &lt;input type="reset" /&gt;
  &lt;input type="password" /&gt;
  &lt;input type="button" /&gt;
  &lt;select&gt;&lt;option/&gt;&lt;/select&gt;
  &lt;textarea&gt;&lt;/textarea&gt;
  &lt;button&gt;&lt;/button&gt;
&lt;/form&gt;</html>
          <code>$(":radio")</code>
          <result>[ &lt;input type="radio" /&gt; ]</result>
        </example>
      </selector>
      <selector name="checkbox" return="Array&lt;Element(s)>">
        <sample>:checkbox</sample>
        <desc>匹配所有复选框</desc>
        <example>
          <desc>查找所有复选框</desc>
          <html>&lt;form&gt;
  &lt;input type="text" /&gt;
  &lt;input type="checkbox" /&gt;
  &lt;input type="radio" /&gt;
  &lt;input type="image" /&gt;
  &lt;input type="file" /&gt;
  &lt;input type="submit" /&gt;
  &lt;input type="reset" /&gt;
  &lt;input type="password" /&gt;
  &lt;input type="button" /&gt;
  &lt;select&gt;&lt;option/&gt;&lt;/select&gt;
  &lt;textarea&gt;&lt;/textarea&gt;
  &lt;button&gt;&lt;/button&gt;
&lt;/form&gt;</html>
          <code>$(":checkbox")</code>
          <result>[ &lt;input type="checkbox" /&gt; ]</result>
        </example>
      </selector>
      <selector name="submit" return="Array&lt;Element(s)>">
        <sample>:submit</sample>
        <desc>匹配所有提交按钮</desc>
        <example>
          <desc>查找所有提交按钮</desc>
          <html>&lt;form&gt;
  &lt;input type="text" /&gt;
  &lt;input type="checkbox" /&gt;
  &lt;input type="radio" /&gt;
  &lt;input type="image" /&gt;
  &lt;input type="file" /&gt;
  &lt;input type="submit" /&gt;
  &lt;input type="reset" /&gt;
  &lt;input type="password" /&gt;
  &lt;input type="button" /&gt;
  &lt;select&gt;&lt;option/&gt;&lt;/select&gt;
  &lt;textarea&gt;&lt;/textarea&gt;
  &lt;button&gt;&lt;/button&gt;
&lt;/form&gt;</html>
          <code>$(":submit")</code>
          <result>[ &lt;input type="submit" /&gt; ]</result>
        </example>
      </selector>
      <selector name="image" return="Array&lt;Element(s)>">
        <sample>:image</sample>
        <desc>匹配所有图像域</desc>
        <example>
          <desc>匹配所有图像域</desc>
          <html>&lt;form&gt;
  &lt;input type="text" /&gt;
  &lt;input type="checkbox" /&gt;
  &lt;input type="radio" /&gt;
  &lt;input type="image" /&gt;
  &lt;input type="file" /&gt;
  &lt;input type="submit" /&gt;
  &lt;input type="reset" /&gt;
  &lt;input type="password" /&gt;
  &lt;input type="button" /&gt;
  &lt;select&gt;&lt;option/&gt;&lt;/select&gt;
  &lt;textarea&gt;&lt;/textarea&gt;
  &lt;button&gt;&lt;/button&gt;
&lt;/form&gt;</html>
          <code>$(":image")</code>
          <result>[ &lt;input type="image" /&gt; ]</result>
        </example>
      </selector>
      <selector name="reset" return="Array&lt;Element(s)>">
        <sample>:reset</sample>
        <desc>匹配所有重置按钮</desc>
        <example>
          <desc>查找所有重置按钮</desc>
          <html>&lt;form&gt;
  &lt;input type="text" /&gt;
  &lt;input type="checkbox" /&gt;
  &lt;input type="radio" /&gt;
  &lt;input type="image" /&gt;
  &lt;input type="file" /&gt;
  &lt;input type="submit" /&gt;
  &lt;input type="reset" /&gt;
  &lt;input type="password" /&gt;
  &lt;input type="button" /&gt;
  &lt;select&gt;&lt;option/&gt;&lt;/select&gt;
  &lt;textarea&gt;&lt;/textarea&gt;
  &lt;button&gt;&lt;/button&gt;
&lt;/form&gt;</html>
          <code>$(":reset")</code>
          <result>[ &lt;input type="reset" /&gt; ]</result>
        </example>
      </selector>
      <selector name="button" return="Array&lt;Element(s)>">
        <sample>:button</sample>
        <desc>匹配所有按钮</desc>
        <example>
          <desc>查找所有按钮.</desc>
          <html>&lt;form&gt;
  &lt;input type="text" /&gt;
  &lt;input type="checkbox" /&gt;
  &lt;input type="radio" /&gt;
  &lt;input type="image" /&gt;
  &lt;input type="file" /&gt;
  &lt;input type="submit" /&gt;
  &lt;input type="reset" /&gt;
  &lt;input type="password" /&gt;
  &lt;input type="button" /&gt;
  &lt;select&gt;&lt;option/&gt;&lt;/select&gt;
  &lt;textarea&gt;&lt;/textarea&gt;
  &lt;button&gt;&lt;/button&gt;
&lt;/form&gt;</html>
          <code>$(":button")</code>
          <result>[ &lt;input type="button" /&gt;,&lt;button&gt;&lt;/button&gt; ]</result>
        </example>
      </selector>
      <selector name="file" return="Array&lt;Element(s)>">
        <sample>:file</sample>
        <desc>匹配所有文件域</desc>
        <example>
          <desc>查找所有文件域</desc>
          <html>&lt;form&gt;
  &lt;input type="text" /&gt;
  &lt;input type="checkbox" /&gt;
  &lt;input type="radio" /&gt;
  &lt;input type="image" /&gt;
  &lt;input type="file" /&gt;
  &lt;input type="submit" /&gt;
  &lt;input type="reset" /&gt;
  &lt;input type="password" /&gt;
  &lt;input type="button" /&gt;
  &lt;select&gt;&lt;option/&gt;&lt;/select&gt;
  &lt;textarea&gt;&lt;/textarea&gt;
  &lt;button&gt;&lt;/button&gt;
&lt;/form&gt;</html>
          <code>$(":file")</code>
          <result>[ &lt;input type="file" /&gt; ]</result>
        </example>
      </selector>
      <selector name="hidden" return="Array&lt;Element(s)>">
        <sample>:hidden</sample>
        <desc>匹配所有不可见元素，或者type为hidden的元素</desc>
        <example>
          <desc>查找隐藏的 tr</desc>
          <html>&lt;table&gt;
  &lt;tr style="display:none"&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</html>
          <code>$("tr:hidden")</code>
          <result>[ &lt;tr style="display:none"&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt; ]</result>
        </example>
        <example>
          <desc>匹配type为hidden的元素</desc>
          <html>&lt;form&gt;
  &lt;input type="text" name="email" /&gt;
  &lt;input type="hidden" name="id" /&gt;
&lt;/form&gt;</html>
          <code>$("input:hidden")</code>
          <result>[ &lt;input type="hidden" name="id" /&gt; ]</result>
        </example>
      </selector>
    </subcat>
    <subcat value="表单对象属性">
      <selector name="enabled" return="Array&lt;Element(s)>">
        <sample>:enabled</sample>
        <desc>匹配所有可用元素</desc>
        <example>
          <desc>查找所有可用的input元素</desc>
          <html>&lt;form&gt;
  &lt;input name="email" disabled="disabled" /&gt;
  &lt;input name="id" /&gt;
&lt;/form&gt;</html>
          <code>$("input:enabled")</code>
          <result>[ &lt;input name="id" /&gt; ]</result>
        </example>
      </selector>
      <selector name="disabled" return="Array&lt;Element(s)>">
        <sample>:disabled</sample>
        <desc>匹配所有不可用元素</desc>
        <example>
          <desc>查找所有不可用的input元素</desc>
          <html>&lt;form&gt;
  &lt;input name="email" disabled="disabled" /&gt;
  &lt;input name="id" /&gt;
&lt;/form&gt;</html>
          <code>$("input:disabled")</code>
          <result>[ &lt;input name="email" disabled="disabled" /&gt; ]</result>
        </example>
      </selector>
      <selector name="checked" return="Array&lt;Element(s)>">
        <sample>:checked</sample>
        <desc>匹配所有选中的被选中元素(复选框、单选框等，不包括select中的option)</desc>
        <example>
          <desc>查找所有选中的复选框元素</desc>
          <html>&lt;form&gt;
  &lt;input type="checkbox" name="newsletter" checked="checked" value="Daily" /&gt;
  &lt;input type="checkbox" name="newsletter" value="Weekly" /&gt;
  &lt;input type="checkbox" name="newsletter" checked="checked" value="Monthly" /&gt;
&lt;/form&gt;</html>
          <code>$("input:checked")</code>
          <result>[ &lt;input type="checkbox" name="newsletter" checked="checked" value="Daily" /&gt;, &lt;input type="checkbox" name="newsletter" checked="checked" value="Monthly" /&gt; ]</result>
        </example>
      </selector>
      <selector name="selected" return="Array&lt;Element(s)>">
        <sample>:selected</sample>
        <desc>匹配所有选中的option元素</desc>
        <example>
          <desc>查找所有选中的选项元素</desc>
          <html>&lt;select&gt;
  &lt;option value="1"&gt;Flowers&lt;/option&gt;
  &lt;option value="2" selected="selected"&gt;Gardens&lt;/option&gt;
  &lt;option value="3"&gt;Trees&lt;/option&gt;
&lt;/select&gt;</html>
          <code>$("select option:selected")</code>
          <result>[ &lt;option value="2" selected="selected"&gt;Gardens&lt;/option&gt; ]</result>
        </example>
      </selector>
    </subcat>
  </cat>
  <cat value="属性">
    <subcat value="属性">
      <function name="attr" return="Object">
        <desc>取得第一个匹配元素的属性值。通过这个方法可以方便地从第一个匹配元素中获取一个属性的值。如果元素没有相应属性，则返回 undefined 。</desc>
        <params name="name" type="String">
          <desc>属性名称</desc>
        </params>
        <example>
          <desc>返回文档中第一个图像的src属性值。</desc>
          <html>&lt;img src="test.jpg"/&gt;</html>
          <code>$("img").attr("src");</code>
          <result>test.jpg</result>
        </example>
      </function>
      <function name="attr" return="JPlus">
        <desc>将一个“名/值”形式的对象设置为所有匹配元素的属性。</desc>
        <longdesc>这是一种在所有匹配元素中批量设置很多属性的最佳方式。 注意，如果你要设置对象的class属性，你必须使用'className' 作为属性名。或者你可以直接使用.addClass( class ) 和 .removeClass( class ).</longdesc>
        <params name="properties" type="Map">
          <desc>作为属性的“名/值对”对象</desc>
        </params>
        <example>
          <desc>为所有图像设置src和alt属性。</desc>
          <html>&lt;img/&gt;</html>
          <code>$("img").attr({ src: "test.jpg", alt: "Test Image" });</code>
          <result>[ &lt;img src= "test.jpg"  alt:="Test Image" /&gt; ]</result>
        </example>
      </function>
      <function name="attr" return="JPlus">
        <desc>为所有匹配的元素设置一个属性值。</desc>
        <params name="key" type="String">
          <desc>属性名称</desc>
        </params>
        <params name="value" type="Object">
          <desc>属性值</desc>
        </params>
        <example>
          <desc>为所有图像设置src属性。</desc>
          <html>&lt;img/&gt; 
&lt;img/&gt;</html>
          <code>$("img").attr("src","test.jpg");</code>
          <result>[ &lt;img src= "test.jpg" /&gt; , &lt;img src= "test.jpg" /&gt; ]</result>
        </example>
      </function>
      <function name="attr" return="JPlus">
        <desc>为所有匹配的元素设置一个计算的属性值。</desc>
        <longdesc>不提供值，而是提供一个函数，由这个函数计算的值作为属性值。</longdesc>
        <params name="key" type="String">
          <desc>属性名称</desc>
        </params>
        <params name="function(index, attr)" type="Function">
          <desc>返回属性值的函数 ，第一个参数为当前元素的索引值，第二个参数为原先的属性值。</desc>
        </params>
        <example>
          <desc>把src属性的值设置为title属性的值。</desc>
          <html>&lt;img src="test.jpg"/&gt;</html>
          <code>$("img").attr("title", function() { return this.src });</code>
          <result>&lt;img src="test.jpg" title="test.jpg" /&gt;</result>
        </example>
      </function>
      <function name="removeAttr" return="JPlus">
        <desc>从每一个匹配的元素中删除一个属性</desc>
        <params name="name" type="String">
          <desc>要删除的属性名</desc>
        </params>
        <example>
          <desc>将文档中图像的src属性删除</desc>
          <html>&lt;img src="test.jpg"/&gt;</html>
          <code>$("img").removeAttr("src");</code>
          <result>[ &lt;img /&gt; ]</result>
        </example>
      </function>
    </subcat>
    <subcat value="CSS 类">
      <function name="addClass" return="JPlus">
        <desc>为每个匹配的元素添加指定的类名。</desc>
        <params name="class" type="String">
          <desc>一个或多个要添加到元素中的CSS类名，请用空格分开</desc>
        </params>
        <example>
          <desc>为匹配的元素加上 'selected' 类</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;</html>
          <code>$("p").addClass("selected");</code>
          <result>[ &lt;p class="selected"&gt;Hello&lt;/p&gt; ]</result>
        </example>
        <example>
          <desc>为匹配的元素加上 selected highlight 类</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;</html>
          <code>$("p").addClass("selected highlight");</code>
          <result>[ &lt;p class="selected highlight"&gt;Hello&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="addClass" return="JPlus">
        <desc>为每个匹配的元素添加指定的类名。</desc>
        <params name="function(index, class)" type="Function">
          <desc>此函数必须返回一个或多个空格分隔的class名。接受两个参数，index参数为对象在这个集合中的索引值，class参数为这个对象原先的class属性值。</desc>
        </params>
        <example>
          <desc>给li加上不同的class</desc>
          <html>&lt;ul&gt;&lt;li&gt;Hello&lt;/li&gt;&lt;li&gt;Hello&lt;/li&gt;&lt;li&gt;Hello&lt;/li&gt;&lt;/ul&gt;</html>
          <code>$('ul li:last').addClass(function() {
  return 'item-' + $(this).index();
});</code>
        </example>
      </function>
      <function name="removeClass" return="JPlus">
        <desc>从所有匹配的元素中删除全部或者指定的类。</desc>
        <params name="class" type="String" optional="true">
          <desc>一个或多个要删除的CSS类名，请用空格分开</desc>
        </params>
        <example>
          <desc>从匹配的元素中删除 'selected' 类</desc>
          <html>&lt;p class="selected first"&gt;Hello&lt;/p&gt;</html>
          <code>$("p").removeClass("selected");</code>
          <result>[ &lt;p class="first"&gt;Hello&lt;/p&gt; ]</result>
        </example>
        <example>
          <desc>删除匹配元素的所有类</desc>
          <html>&lt;p class="selected first"&gt;Hello&lt;/p&gt;</html>
          <code>$("p").removeClass();</code>
          <result>[ &lt;p&gt;Hello&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="removeClass" return="JPlus">
        <desc>从所有匹配的元素中删除全部或者指定的类。</desc>
        <params name="function(index, class)" type="Function">
          <desc>此函数必须返回一个或多个空格分隔的class名。接受两个参数，index参数为对象在这个集合中的索引值，class参数为这个对象原先的class属性值。</desc>
        </params>
        <example>
          <desc>删除最后一个元素上与前面重复的class</desc>
          <code>$('li:last').removeClass(function() {
    return $(this).prev().attr('class');
});</code>
        </example>
      </function>
      <function name="toggleClass" return="JPlus">
        <desc>如果存在（不存在）就删除（添加）一个类。</desc>
        <params name="class" type="String">
          <desc>CSS类名</desc>
        </params>
        <example>
          <desc>为匹配的元素切换 'selected' 类</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p class="selected"&gt;Hello Again&lt;/p&gt;</html>
          <code>$("p").toggleClass("selected");</code>
          <result>[ &lt;p class="selected"&gt;Hello&lt;/p&gt;, &lt;p&gt;Hello Again&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="toggleClass" return="JPlus">
        <desc>如果开关switch参数为true则加上对应的class，否则就删除。</desc>
        <params name="class" type="String">
          <desc>要切换的CSS类名</desc>
        </params>
        <params name="switch" type="Boolean">
          <desc>用于决定元素是否包含class的布尔值。</desc>
        </params>
        <example>
          <desc>每点击三下加上一次 'highlight' 类</desc>
          <html>&lt;strong&gt;JPlus 代码:&lt;/strong&gt;</html>
          <code>  var count = 0;
  $("p").click(function(){
      $(this).toggleClass("highlight", count++ % 3 == 0);
  });</code>
        </example>
      </function>
      <function name="toggleClass" return="JPlus">
        <desc>如果开关switch参数为true则加上对应的class，否则就删除。</desc>
        <params name="function(index, class)" type="Function">
          <desc>返回class名的一个函数，接受两个参数，index为元素在集合中的索引位置，class为原先元素的class值。</desc>
        </params>
        <params name="switch" type="Boolean" optional="true">
          <desc>用于决定元素是否包含class的布尔值。</desc>
        </params>
        <example>
          <desc>根据父元素来设置class属性</desc>
          <code>$('div.foo').toggleClass(function() {
  if ($(this).parent().is('.bar') {
    return 'happy';
  } else {
    return 'sad';
  }
});</code>
        </example>
      </function>
    </subcat>
    <subcat value="HTML代码">
      <function name="html" return="String">
        <desc>取得第一个匹配元素的html内容。这个函数不能用于XML文档。但可以用于XHTML文档。</desc>
      </function>
      <function name="html" return="JPlus">
        <desc>设置每一个匹配元素的html内容。这个函数不能用于XML文档。但可以用于XHTML文档。</desc>
        <params name="val" type="String">
          <desc>用于设定HTML内容的值</desc>
        </params>
      </function>
      <function name="html" return="JPlus">
        <desc>设置每一个匹配元素的html内容。这个函数不能用于XML文档。但可以用于XHTML文档。</desc>
        <params name="function(index, html)" type="Function">
          <desc>此函数返回一个HTML字符串。接受两个参数，index为元素在集合中的索引位置，html为原先的HTML值。</desc>
        </params>
      </function>
    </subcat>
    <subcat value="文本">
      <function name="text" return="String">
        <desc>取得所有匹配元素的内容。</desc>
        <longdesc>结果是由所有匹配元素包含的文本内容组合起来的文本。这个方法对HTML和XML文档都有效。</longdesc>
      </function>
      <function name="text" return="JPlus">
        <desc>设置所有匹配元素的文本内容</desc>
        <longdesc>与 html() 类似, 但将编码 HTML (将 "&lt;" 和 "&gt;" 替换成相应的HTML实体).</longdesc>
        <params name="val" type="String">
          <desc>用于设置元素内容的文本</desc>
        </params>
      </function>
      <function name="text" return="JPlus">
        <desc>设置所有匹配元素的文本内容</desc>
        <longdesc>与 html() 类似, 但将编码 HTML (将 "&lt;" 和 "&gt;" 替换成相应的HTML实体).</longdesc>
        <params name="function(index, text)" type="Function">
          <desc>此函数返回一个字符串。接受两个参数，index为元素在集合中的索引位置，text为原先的text值。</desc>
        </params>
      </function>
    </subcat>
    <subcat value="值">
      <function name="val" return="String,Array">
        <desc>获得第一个匹配元素的当前值。</desc>
        <longdesc>在 JPlus 1.2 中,可以返回任意元素的值了。包括select。如果多选，将返回一个数组，其包含所选的值。</longdesc>
        <example>
          <desc>获得单个select的值和多选select的值。</desc>
          <html>&lt;p&gt;&lt;/p&gt;&lt;br/&gt;
&lt;select id="single"&gt;
  &lt;option&gt;Single&lt;/option&gt;
  &lt;option&gt;Single2&lt;/option&gt;
&lt;/select&gt;
&lt;select id="multiple" multiple="multiple"&gt;
  &lt;option selected="selected"&gt;Multiple&lt;/option&gt;
  &lt;option&gt;Multiple2&lt;/option&gt;
  &lt;option selected="selected"&gt;Multiple3&lt;/option&gt;
&lt;/select&gt;</html>
          <code>$("p").append(
  "&lt;b&gt;Single:&lt;/b&gt; "   + $("#single").val() +
  " &lt;b&gt;Multiple:&lt;/b&gt; " + $("#multiple").val().join(", ")
);</code>
          <result>[ &lt;p&gt;&lt;b&gt;Single:&lt;/b&gt;Single&lt;b&gt;Multiple:&lt;/b&gt;Multiple, Multiple3&lt;/p&gt;]</result>
        </example>
        <example>
          <desc>获取文本框中的值</desc>
          <html>&lt;input type="text" value="some text"/&gt;</html>
          <code>$("input").val();</code>
          <result>some text</result>
        </example>
      </function>
      <function name="val" return="JPlus">
        <desc>设置每一个匹配元素的值。</desc>
        <longdesc>在 JPlus 1.2, 这也可以为select元件赋值</longdesc>
        <params name="val" type="String">
          <desc>要设置的值。</desc>
        </params>
        <example>
          <desc>设定文本框的值</desc>
          <html>&lt;input type="text"/&gt;</html>
          <code>$("input").val("hello world!");</code>
        </example>
      </function>
      <function name="val" return="JPlus">
        <desc>check,select,radio等都能使用为之赋值</desc>
        <params name="array" type="Array&lt;String&gt;">
          <desc>用于 check/select 的值</desc>
        </params>
        <example>
          <desc>设定一个select和一个多选的select的值</desc>
          <html>&lt;select id="single"&gt;
  &lt;option&gt;Single&lt;/option&gt;
  &lt;option&gt;Single2&lt;/option&gt;
&lt;/select&gt;
&lt;select id="multiple" multiple="multiple"&gt;
  &lt;option selected="selected"&gt;Multiple&lt;/option&gt;
  &lt;option&gt;Multiple2&lt;/option&gt;
  &lt;option selected="selected"&gt;Multiple3&lt;/option&gt;
&lt;/select&gt;&lt;br/&gt;
&lt;input type="checkbox" value="check1"/&gt; check1
&lt;input type="checkbox" value="check2"/&gt; check2
&lt;input type="radio" value="radio1"/&gt; radio1
&lt;input type="radio" value="radio2"/&gt; radio2</html>
          <code>$("#single").val("Single2");
$("#multiple").val(["Multiple2", "Multiple3"]);
$("input").val(["check2", "radio1"]);</code>
        </example>
      </function>
      <function name="val" return="JPlus">
        <desc>设置每一个匹配元素的值。</desc>
        <longdesc>在 JPlus 1.2, 这也可以为select元件赋值</longdesc>
        <params name="function(index, value)" type="Function">
          <desc>此函数返回一个要设置的值。接受两个参数，index为元素在集合中的索引位置，text为原先的text值。</desc>
        </params>
        <example>
          <desc>设定文本框的值</desc>
          <html>&lt;input type="text" class="items"/&gt;</html>
          <code>$('input:text.items').val(function() {
  return this.value + ' ' + this.className;
});</code>
        </example>
      </function>
    </subcat>
  </cat>
  <cat value="筛选">
    <subcat value="过滤">
      <function name="eq" return="JPlus">
        <desc>获取第N个元素</desc>
        <longdesc>这个元素的位置是从0算起。</longdesc>
        <params name="index" type="Integer">
          <desc>元素在JPlus对象中的索引</desc>
		  <longdesc>从JPlus 1.4 起，这个值也支持负数，比如 -2 就是获取倒数第二个元素。</longdesc>
        </params>
        <example>
          <desc>获取匹配的第二个元素</desc>
          <html>&lt;p&gt; This is just a test.&lt;/p&gt; &lt;p&gt; So is this&lt;/p&gt;</html>
          <code>$("p").eq(1)</code>
          <result>[ &lt;p&gt; So is this&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="first" return="JPlus">
        <desc>获取第一个元素</desc>
        <example>
          <desc>获取匹配的第一个元素</desc>
          <html>&lt;ul&gt;
    &lt;li&gt;list item 1&lt;/li&gt;
    &lt;li&gt;list item 2&lt;/li&gt;
    &lt;li&gt;list item 3&lt;/li&gt;
    &lt;li&gt;list item 4&lt;/li&gt;
    &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;</html>
          <code>$('li').first()</code>
          <result>[ &lt;li&gt;list item 1&lt;/li&gt; ]</result>
        </example>
      </function>
      <function name="last" return="JPlus">
        <desc>获取最后个元素</desc>
        <example>
          <desc>获取匹配的最后个元素</desc>
          <html>&lt;ul&gt;
    &lt;li&gt;list item 1&lt;/li&gt;
    &lt;li&gt;list item 2&lt;/li&gt;
    &lt;li&gt;list item 3&lt;/li&gt;
    &lt;li&gt;list item 4&lt;/li&gt;
    &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;</html>
          <code>$('li').last()</code>
          <result>[ &lt;li&gt;list item 5&lt;/li&gt; ]</result>
        </example>
      </function>
      <function name="hasClass" return="Boolean">
        <desc>检查当前的元素是否含有某个特定的类，如果有，则返回true。</desc>
        <longdesc>这其实就是 is("." + class)。</longdesc>
        <params name="class" type="String">
          <desc>用于匹配的类名</desc>
        </params>
        <example>
          <desc>给包含有某个类的元素进行一个动画。</desc>
          <html>&lt;div class="protected"&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;</html>
          <code>$("div").click(function(){
  if ( $(this).hasClass("protected") )
    $(this)
      .animate({ left: -10 })
      .animate({ left: 10 })
      .animate({ left: -10 })
      .animate({ left: 10 })
      .animate({ left: 0 });
});</code>
        </example>
      </function>
      <function name="filter" return="JPlus">
        <desc>筛选出与指定表达式匹配的元素集合。</desc>
        <longdesc>这个方法用于缩小匹配的范围。用逗号分隔多个表达式</longdesc>
        <params name="expr" type="Expression">
          <desc>表达式</desc>
        </params>
        <example>
          <desc>保留带有select类的元素</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;Hello Again&lt;/p&gt;&lt;p class="selected"&gt;And Again&lt;/p&gt;</html>
          <code>$("p").filter(".selected")</code>
          <result>[ &lt;p class="selected"&gt;And Again&lt;/p&gt; ]</result>
        </example>
        <example>
          <desc>保留第一个以及带有select类的元素</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;Hello Again&lt;/p&gt;&lt;p class="selected"&gt;And Again&lt;/p&gt;</html>
          <code>$("p").filter(".selected, :first")</code>
          <result>[ &lt;p&gt;Hello&lt;/p&gt;, &lt;p class="selected"&gt;And Again&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="filter" return="JPlus">
        <desc>筛选出与指定函数返回值匹配的元素集合</desc>
        <longdesc>这个函数内部将对每个对象计算一次 (正如 '$.each'). 如果调用的函数返回false则这个元素被删除，否则就会保留。</longdesc>
        <params name="fn" type="Function">
          <desc>传递进filter的函数</desc>
        </params>
        <example>
          <desc>保留子元素中不含有ol的元素。</desc>
          <html>&lt;p&gt;&lt;ol&gt;&lt;li&gt;Hello&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt;&lt;p&gt;How are you?&lt;/p&gt;</html>
          <code>$("p").filter(function(index) {
  return $("ol", this).length == 0;
});</code>
          <result>[ &lt;p&gt;How are you?&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="is" return="Boolean">
        <desc>用一个表达式来检查当前选择的元素集合，如果其中至少有一个元素符合这个给定的表达式就返回true。</desc>
        <longdesc>如果没有元素符合，或者表达式无效，都返回'false'。

'''注意：'''在JPlus 1.3中才对所有表达式提供了支持。在先前版本中，如果提供了复杂的表达式，比如层级选择器（比如 + , ~ 和 &gt; ），始终会返回true</longdesc>
        <params name="expr" type="String">
          <desc>用于筛选的表达式</desc>
        </params>
        <example>
          <desc>由于input元素的父元素是一个表单元素，所以返回true。</desc>
          <html>&lt;form&gt;&lt;input type="checkbox" /&gt;&lt;/form&gt;</html>
          <code>$("input[type='checkbox']").parent().is("form")</code>
          <result>true</result>
        </example>
      </function>
      <function name="map" return="JPlus">
        <desc>将一组元素转换成其他数组（不论是否是元素数组）</desc>
        <longdesc>你可以用这个函数来建立一个列表，不论是值、属性还是CSS样式，或者其他特别形式。这都可以用'$.map()'来方便的建立。</longdesc>
        <params name="callback" type="Function">
          <desc>给每个元素执行的函数</desc>
        </params>
        <example>
          <desc>把form中的每个input元素的值建立一个列表。</desc>
          <html>&lt;p&gt;&lt;b&gt;Values: &lt;/b&gt;&lt;/p&gt;
&lt;form&gt;
  &lt;input type="text" name="name" value="John"/&gt;
  &lt;input type="text" name="password" value="password"/&gt;
  &lt;input type="text" name="url" value="http://ejohn.org/"/&gt;
&lt;/form&gt;</html>
          <code>$("p").append( $("input").map(function(){
  return $(this).val();
}).get().join(", ") );</code>
          <result>[ &lt;p&gt;John, password, http://ejohn.org/&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="has" return="JPlus">
        <desc>保留包含特定后代的元素，去掉那些不含有指定后代的元素。</desc>
        <longdesc>.has()方法将会从给定的JPlus对象中重新创建一组匹配的对象。提供的选择器会一一测试原先那些对象的后代，含有匹配后代的对象将得以保留。</longdesc>
        <params name="expr" type="String, DOMElement, Array&lt;DOMElement&gt;">
          <desc>一个表达式、一个元素或者一组元素</desc>
        </params>
        <example>
          <desc>给含有ul的li加上背景色</desc>
          <html>&lt;ul&gt;
  &lt;li&gt;list item 1&lt;/li&gt;
  &lt;li&gt;list item 2
    &lt;ul&gt;
      &lt;li&gt;list item 2-a&lt;/li&gt;
      &lt;li&gt;list item 2-b&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;list item 3&lt;/li&gt;
  &lt;li&gt;list item 4&lt;/li&gt;
&lt;/ul&gt;</html>
          <code>$('li').has('ul').css('background-color', 'red');</code>
        </example>
      </function>
      <function name="not" return="JPlus">
        <desc>删除与指定表达式匹配的元素</desc>
        <params name="expr" type="String, DOMElement, Array&lt;DOMElement&gt;">
          <desc>一个表达式、一个元素或者一组元素</desc>
        </params>
        <example>
          <desc>从p元素中删除带有 select 的ID的元素</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p id="selected"&gt;Hello Again&lt;/p&gt;</html>
          <code>$("p").not( $("#selected")[0] )</code>
          <result>[ &lt;p&gt;Hello&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="slice" return="JPlus">
        <desc>选取一个匹配的子集</desc>
        <longdesc>与原来的slice方法类似</longdesc>
        <params name="start" type="Integer">
          <desc>开始选取子集的位置。第一个元素是0.如果是负数，则可以从集合的尾部开始选起。</desc>
        </params>
        <params name="end" type="Integer" optional="true">
          <desc>结束选取自己的位置，如果不指定，则就是本身的结尾。</desc>
        </params>
        <example>
          <desc>选择第一个p元素</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;</html>
          <code>$("p").slice(0, 1).wrapInner("&lt;b&gt;&lt;/b&gt;");</code>
          <result>[ &lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;&lt;/p&gt; ]</result>
        </example>
        <example>
          <desc>选择前两个p元素</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;</html>
          <code>$("p").slice(0, 2).wrapInner("&lt;b&gt;&lt;/b&gt;");</code>
          <result>[ &lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;&lt;/p&gt;,&lt;p&gt;&lt;b&gt;cruel&lt;/b&gt;&lt;/p&gt; ]</result>
        </example>
        <example>
          <desc>只选取第二个p元素</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;</html>
          <code>$("p").slice(1, 2).wrapInner("&lt;b&gt;&lt;/b&gt;");</code>
          <result>[ &lt;p&gt;&lt;b&gt;cruel&lt;/b&gt;&lt;/p&gt; ]</result>
        </example>
        <example>
          <desc>只选取第二第三个p元素</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;</html>
          <code>$("p").slice(1).wrapInner("&lt;b&gt;&lt;/b&gt;");</code>
          <result>[ &lt;p&gt;&lt;b&gt;cruel&lt;/b&gt;&lt;/p&gt;, &lt;p&gt;&lt;b&gt;World&lt;/b&gt;&lt;/p&gt; ]</result>
        </example>
        <example>
          <desc>选取第最后一个p元素</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;</html>
          <code>$("p").slice(-1).wrapInner("&lt;b&gt;&lt;/b&gt;");</code>
          <result>[ &lt;p&gt;&lt;b&gt;World&lt;/b&gt;&lt;/p&gt; ]</result>
        </example>
      </function>
    </subcat>
    <subcat value="查找">
		  <function name="find" return="JPlus">
        <desc>搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。</desc>
        <longdesc>所有搜索都依靠JPlus表达式来完成。这个表达式可以使用CSS1-3的选择器语法来写。</longdesc>
        <params name="expr" type="String">
          <desc>用于查找的表达式</desc>
        </params>
        <example>
          <desc>从所有的段落开始，进一步搜索下面的span元素。与$("p span")相同。</desc>
          <html>&lt;p&gt;&lt;span&gt;Hello&lt;/span&gt;, how are you?&lt;/p&gt;</html>
          <code>$("p").find("span")</code>
          <result>[ &lt;span&gt;Hello&lt;/span&gt; ]</result>
        </example>
      </function>
      <function name="children" return="JPlus">
        <desc>取得一个包含匹配的元素集合中每一个元素的所有子元素的元素集合。</desc>
        <longdesc>可以通过可选的表达式来过滤所匹配的子元素。注意：parents()将查找所有祖辈元素，而children()只考虑子元素而不考虑所有后代元素。</longdesc>
        <params name="expr" type="String" optional="true">
          <desc>用以过滤子元素的表达式</desc>
        </params>
        <example>
          <desc>查找DIV中的每个子元素。</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;div&gt;&lt;span&gt;Hello Again&lt;/span&gt;&lt;/div&gt;&lt;p&gt;And Again&lt;/p&gt;</html>
          <code>$("div").children()</code>
          <result>[ &lt;span&gt;Hello Again&lt;/span&gt; ]</result>
        </example>
        <example>
          <desc>在每个div中查找 .selected 的类。</desc>
          <html>&lt;div&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;p class="selected"&gt;Hello Again&lt;/p&gt;&lt;p&gt;And Again&lt;/p&gt;&lt;/div&gt;</html>
          <code>$("div").children(".selected")</code>
          <result>[ &lt;p class="selected"&gt;Hello Again&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="closest" return="JPlus">
        <desc>JPlus 1.3新增。从元素本身开始，逐级向上级元素匹配，并返回最先匹配的元素。</desc>
        <longdesc>closest会首先检查当前元素是否匹配，如果匹配则直接返回元素本身。如果不匹配则向上查找父元素，一层一层往上，直到找到匹配选择器的元素。如果什么都没找到则返回一个空的JPlus对象。

		closest和parents的主要区别是：1，前者从当前元素开始匹配寻找，后者从父元素开始匹配寻找；2，前者逐级向上查找，直到发现匹配的元素后就停止了，后者一直向上查找直到根元素，然后把这些元素放进一个临时集合中，再用给定的选择器表达式去过滤；3，前者返回0或1个元素，后者可能包含0个，1个，或者多个元素。		

		closest对于处理事件委托非常有用。
</longdesc>
        <params name="expr" type="String, Array">
          <desc>用以过滤元素的表达式。JPlus 1.4开始，也可以传递一个字符串数组，用于查找多个元素。</desc>
        </params>
        <params name="context" type="Element, JPlus" optional="true">
          <desc>作为待查找的 DOM 元素集、文档或 JPlus 对象。</desc>
        </params>
        <example>
          <desc>展示如何使用clostest查找多个元素</desc>
          <html>&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</html>
          <code>$("li:first").closest(["ul", "body"]);</code>
		  <result>[ul, body]</result>
        </example>
        <example>
          <desc>展示如何使用clostest来完成事件委托。</desc>
          <html>&lt;ul&gt;
    &lt;li&gt;&lt;b&gt;Click me!&lt;/b&gt;&lt;/li&gt;
    &lt;li&gt;You can also &lt;b&gt;Click me!&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;</html>
          <code>$(document).bind("click", function (e) {
    $(e.target).closest("li").toggleClass("hilight");
});</code>
        </example>
		</function>
      <function name="next" return="JPlus">
        <desc>取得一个包含匹配的元素集合中每一个元素紧邻的后面同辈元素的元素集合。</desc>
        <longdesc>这个函数只返回后面那个紧邻的同辈元素，而不是后面所有的同辈元素（可以使用nextAll）。可以用一个可选的表达式进行筛选。</longdesc>
        <params name="expr" type="String" optional="true">
          <desc>用于筛选的表达式</desc>
        </params>
        <example>
          <desc>找到每个段落的后面紧邻的同辈元素。</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;Hello Again&lt;/p&gt;&lt;div&gt;&lt;span&gt;And Again&lt;/span&gt;&lt;/div&gt;</html>
          <code>$("p").next()</code>
          <result>[ &lt;p&gt;Hello Again&lt;/p&gt;, &lt;div&gt;&lt;span&gt;And Again&lt;/span&gt;&lt;/div&gt; ]</result>
        </example>
        <example>
          <desc>找到每个段落的后面紧邻的同辈元素中类名为selected的元素。</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p class="selected"&gt;Hello Again&lt;/p&gt;&lt;div&gt;&lt;span&gt;And Again&lt;/span&gt;&lt;/div&gt;</html>
          <code>$("p").next(".selected")</code>
          <result>[ &lt;p class="selected"&gt;Hello Again&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="nextAll" return="JPlus">
        <desc>查找当前元素之后所有的同辈元素。</desc>
        <longdesc>可以用表达式过滤</longdesc>
        <params name="expr" type="String" optional="true">
          <desc>(可选)用来过滤的表达式</desc>
        </params>
        <example>
          <desc>给第一个div之后的所有元素加个类</desc>
          <html>&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;</html>
          <code>$("div:first").nextAll().addClass("after");</code>
          <result>[ &lt;div class="after"&gt;&lt;/div&gt;, &lt;div class="after"&gt;&lt;/div&gt;, &lt;div class="after"&gt;&lt;/div&gt; ]</result>
        </example>
      </function>
      <function name="nextUntil" return="JPlus">
        <desc>查找当前元素之后所有的同辈元素，直到遇到匹配的那个元素为止。</desc>
        <longdesc>如果提供的JPlus代表了一组DOM元素，.nextUntil()方法也能让我们找遍所有元素所在的DOM树，直到遇到了一个跟提供的参数匹配的元素的时候才会停下来。这个新JPlus对象里包含了下面所有找到的同辈元素，但不包括那个选择器匹配到的元素。
		
		如果没有选择器匹配到，或者没有提供参数，那么跟在后面的所有同辈元素都会被选中。这就跟用没有提供参数的 .nextAll()效果一样。</longdesc>
        <params name="expr" type="String" optional="true">
          <desc>(可选)用来过滤的表达式</desc>
        </params>
        <example>
          <desc>给#term-2后面直到dt前的元素加上红色背景</desc>
          <html>&lt;dl&gt;
  &lt;dt&gt;term 1&lt;/dt&gt;
  &lt;dd&gt;definition 1-a&lt;/dd&gt;
  &lt;dd&gt;definition 1-b&lt;/dd&gt;
  &lt;dd&gt;definition 1-c&lt;/dd&gt;
  &lt;dd&gt;definition 1-d&lt;/dd&gt;

  &lt;dt id=&quot;term-2&quot;&gt;term 2&lt;/dt&gt;
  &lt;dd&gt;definition 2-a&lt;/dd&gt;
  &lt;dd&gt;definition 2-b&lt;/dd&gt;
  &lt;dd&gt;definition 2-c&lt;/dd&gt;

  &lt;dt&gt;term 3&lt;/dt&gt;
  &lt;dd&gt;definition 3-a&lt;/dd&gt;
  &lt;dd&gt;definition 3-b&lt;/dd&gt;
&lt;/dl&gt;</html>
          <code>$('#term-2').nextUntil('dt').css('background-color', 'red');</code>
        </example>
      </function>
      <function name="offsetParent" return="JPlus">
        <desc>返回第一个匹配元素用于定位的父节点。</desc>
        <longdesc>这返回父元素中第一个其position设为relative或者absolute的元素。此方法仅对可见元素有效。</longdesc>
      </function>
      <function name="parent" return="JPlus">
        <desc>取得一个包含着所有匹配元素的唯一父元素的元素集合。</desc>
        <longdesc>你可以使用可选的表达式来筛选。</longdesc>
        <params name="expr" type="String" optional="true">
          <desc>(可选)用来筛选的表达式</desc>
        </params>
        <example>
          <desc>查找每个段落的父元素</desc>
          <html>&lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</html>
          <code>$("p").parent()</code>
          <result>[ &lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;]</result>
        </example>
        <example>
          <desc>查找段落的父元素中每个类名为selected的父元素。</desc>
          <html>&lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;&lt;div class="selected"&gt;&lt;p&gt;Hello Again&lt;/p&gt;&lt;/div&gt;</html>
          <code>$("p").parent(".selected")</code>
          <result>[ &lt;div class="selected"&gt;&lt;p&gt;Hello Again&lt;/p&gt;&lt;/div&gt; ]</result>
        </example>
      </function>
      <function name="parents" return="JPlus">
        <desc>取得一个包含着所有匹配元素的祖先元素的元素集合（不包含根元素）。可以通过一个可选的表达式进行筛选。</desc>
        <params name="expr" type="String" optional="true">
          <desc>用于筛选祖先元素的表达式</desc>
        </params>
        <example>
          <desc>找到每个span元素的所有祖先元素。</desc>
          <html>&lt;html&gt;&lt;body&gt;&lt;div&gt;&lt;p&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;/p&gt;&lt;span&gt;Hello Again&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</html>
          <code>$("span").parents()</code>
        </example>
        <example>
          <desc>找到每个span的所有是p元素的祖先元素。</desc>
          <code>$("span").parents("p")</code>
        </example>
      </function>
      <function name="parentsUntil" return="JPlus">
        <desc>查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止。</desc>
        <longdesc>如果提供的JPlus代表了一组DOM元素，.parentsUntil()方法也能让我们找遍所有元素的祖先元素，直到遇到了一个跟提供的参数匹配的元素的时候才会停下来。这个返回的JPlus对象里包含了下面所有找到的父辈元素，但不包括那个选择器匹配到的元素。
		
		</longdesc>
        <params name="expr" type="String" optional="true">
          <desc>用于筛选祖先元素的表达式</desc>
        </params>
        <example>
          <desc>查找item-a的祖先，但不包括level-1</desc>
          <html>&lt;ul class=&quot;level-1&quot;&gt;
  &lt;li class=&quot;item-i&quot;&gt;I&lt;/li&gt;
  &lt;li class=&quot;item-ii&quot;&gt;II
    &lt;ul class=&quot;level-2&quot;&gt;
      &lt;li class=&quot;item-a&quot;&gt;A&lt;/li&gt;
      &lt;li class=&quot;item-b&quot;&gt;B
        &lt;ul class=&quot;level-3&quot;&gt;
          &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt;
          &lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt;
          &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li class=&quot;item-c&quot;&gt;C&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class=&quot;item-iii&quot;&gt;III&lt;/li&gt;
&lt;/ul&gt;</html>
          <code>$('li.item-a').parentsUntil('.level-1')
    .css('background-color', 'red');</code>
        </example>
      </function>
      <function name="prev" return="JPlus">
        <desc>取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合。</desc>
        <longdesc>可以用一个可选的表达式进行筛选。只有紧邻的同辈元素会被匹配到，而不是前面所有的同辈元素。</longdesc>
        <params name="expr" type="String" optional="true">
          <desc>用于筛选前一个同辈元素的表达式</desc>
        </params>
        <example>
          <desc>找到每个段落紧邻的前一个同辈元素。</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;div&gt;&lt;span&gt;Hello Again&lt;/span&gt;&lt;/div&gt;&lt;p&gt;And Again&lt;/p&gt;</html>
          <code>$("p").prev()</code>
          <result>[ &lt;div&gt;&lt;span&gt;Hello Again&lt;/span&gt;&lt;/div&gt; ]</result>
        </example>
        <example>
          <desc>找到每个段落紧邻的前一个同辈元素中类名为selected的元素。</desc>
          <html>&lt;div&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;/div&gt;&lt;p class="selected"&gt;Hello Again&lt;/p&gt;&lt;p&gt;And Again&lt;/p&gt;</html>
          <code>$("p").prev(".selected")</code>
          <result>[ &lt;p class="selected"&gt;Hello Again&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="prevAll" return="JPlus">
        <desc>查找当前元素之前所有的同辈元素</desc>
        <longdesc>可以用表达式过滤。</longdesc>
        <params name="expr" type="String" optional="true">
          <desc>用于过滤的表达式</desc>
        </params>
        <example>
          <desc>给最后一个之前的所有div加上一个类</desc>
          <html>&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;</html>
          <code>$("div:last").prevAll().addClass("before");</code>
          <result>[ &lt;div class="before"&gt;&lt;/div&gt;, &lt;div class="before"&gt;&lt;/div&gt;, &lt;div class="before"&gt;&lt;/div&gt; ]</result>
        </example>
      </function>
      <function name="prevUntil" return="JPlus">
        <desc>查找当前元素之前所有的同辈元素，直到遇到匹配的那个元素为止。</desc>
        <longdesc>如果提供的JPlus代表了一组DOM元素，.prevUntil()方法也能让我们找遍所有元素所在的DOM树，直到遇到了一个跟提供的参数匹配的元素的时候才会停下来。这个新JPlus对象里包含了前面所有找到的同辈元素，但不包括那个选择器匹配到的元素。
		
		如果没有选择器匹配到，或者没有提供参数，那么排在前面的所有同辈元素都会被选中。这就跟用没有提供参数的 .prevAll()效果一样。</longdesc>
        <params name="expr" type="String" optional="true">
          <desc>(可选)用来过滤的表达式</desc>
        </params>
        <example>
          <desc>给#term-2前面直到dt前的元素加上红色背景</desc>
          <html>&lt;dl&gt;
  &lt;dt&gt;term 1&lt;/dt&gt;
  &lt;dd&gt;definition 1-a&lt;/dd&gt;
  &lt;dd&gt;definition 1-b&lt;/dd&gt;
  &lt;dd&gt;definition 1-c&lt;/dd&gt;
  &lt;dd&gt;definition 1-d&lt;/dd&gt;

  &lt;dt id=&quot;term-2&quot;&gt;term 2&lt;/dt&gt;
  &lt;dd&gt;definition 2-a&lt;/dd&gt;
  &lt;dd&gt;definition 2-b&lt;/dd&gt;
  &lt;dd&gt;definition 2-c&lt;/dd&gt;

  &lt;dt&gt;term 3&lt;/dt&gt;
  &lt;dd&gt;definition 3-a&lt;/dd&gt;
  &lt;dd&gt;definition 3-b&lt;/dd&gt;
&lt;/dl&gt;</html>
          <code>$('#term-2').prevUntil('dt').css('background-color', 'red');</code>
        </example>
      </function>
      <function name="siblings" return="JPlus">
        <desc>取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合。可以用可选的表达式进行筛选。</desc>
        <params name="expr" type="String" optional="true">
          <desc>用于筛选同辈元素的表达式</desc>
        </params>
        <example>
          <desc>找到每个div的所有同辈元素。</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;div&gt;&lt;span&gt;Hello Again&lt;/span&gt;&lt;/div&gt;&lt;p&gt;And Again&lt;/p&gt;</html>
          <code>$("div").siblings()</code>
          <result>[ &lt;p&gt;Hello&lt;/p&gt;, &lt;p&gt;And Again&lt;/p&gt; ]</result>
        </example>
        <example>
          <desc>找到每个div的所有同辈元素中带有类名为selected的元素。</desc>
          <html>&lt;div&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;/div&gt;&lt;p class="selected"&gt;Hello Again&lt;/p&gt;&lt;p&gt;And Again&lt;/p&gt;</html>
          <code>$("div").siblings(".selected")</code>
          <result>[ &lt;p class="selected"&gt;Hello Again&lt;/p&gt; ]</result>
        </example>
      </function>
    </subcat>
    <subcat value="串联">
      <function name="add" return="JPlus">
        <desc>把与表达式匹配的元素添加到JPlus对象中。这个函数可以用于连接分别与两个表达式匹配的元素结果集。</desc>
        <longdesc>JPlus 1.4 中， .add()方法返回的结果将始终以元素在HTML文档中出现的顺序来排序，而不再是简单的添加。</longdesc>
        <params name="expr" type="String, DOMElement, Array&lt;DOMElement&gt;">
          <desc>用于匹配元素并添加的表达式字符串，或者用于动态生成的HTML代码，如果是一个字符串数组则返回多个元素</desc>
        </params>
        <params name="context" type="Element, JPlus" optional="true">
          <desc>作为待查找的 DOM 元素集、文档或 JPlus 对象。</desc>
        </params>
        <example>
          <desc>添加一个新元素到一组匹配的元素中，并且这个新元素能匹配给定的表达式。</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;span&gt;Hello Again&lt;/span&gt;</html>
          <code>$("p").add("span")</code>
          <result>[ &lt;p&gt;Hello&lt;/p&gt;, &lt;span&gt;Hello Again&lt;/span&gt; ]</result>
        </example>
        <example>
          <desc>动态生成一个元素并添加至匹配的元素中</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;</html>
          <code>$("p").add("&lt;span&gt;Again&lt;/span&gt;")</code>
          <result>[ &lt;p&gt;Hello&lt;/p&gt;, &lt;span&gt;Hello Again&lt;/span&gt; ]</result>
        </example>
        <example>
          <desc>为匹配的元素添加一个或者多个元素</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;&lt;span id="a"&gt;Hello Again&lt;/span&gt;&lt;/p&gt;</html>
          <code>$("p").add(document.getElementById("a"))</code>
          <result>[ &lt;p&gt;Hello&lt;/p&gt;, &lt;p&gt;&lt;span id="a"&gt;Hello Again&lt;/span&gt;&lt;/p&gt;, &lt;span id="a"&gt;Hello Again&lt;/span&gt; ]</result>
        </example>
      </function>
      <function name="andSelf" return="JPlus">
        <desc>加入先前所选的加入当前元素中</desc>
        <longdesc>对于筛选或查找后的元素，要加入先前所选元素时将会很有用。</longdesc>
        <example>
          <desc>选取所有div以及内部的p，并加上border类</desc>
          <html>&lt;div&gt;&lt;p&gt;First Paragraph&lt;/p&gt;&lt;p&gt;Second Paragraph&lt;/p&gt;&lt;/div&gt;</html>
          <code>$("div").find("p").andSelf().addClass("border");</code>
          <result>&lt;div class="border"&gt;
    &lt;p class="border"&gt;First Paragraph&lt;/p&gt;
    &lt;p class="border"&gt;Second Paragraph&lt;/p&gt;
&lt;/div&gt;</result>
        </example>
      </function>
      <function name="contents" return="JPlus">
        <desc>查找匹配元素内部所有的子节点（包括文本节点）。如果元素是一个iframe，则查找文档内容</desc>
        <example>
          <desc>查找所有文本节点并加粗</desc>
          <html>&lt;p&gt;Hello &lt;a href="http://ejohn.org/"&gt;John&lt;/a&gt;, how are you doing?&lt;/p&gt;</html>
          <code>$("p").contents().not("[nodeType=1]").wrap("&lt;b/&gt;");</code>
          <result>&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt; &lt;a href="http://ejohn.org/"&gt;John&lt;/a&gt;, &lt;b&gt;how are you doing?&lt;/b&gt;&lt;/p&gt;</result>
        </example>
        <example>
          <desc>往一个空框架中加些内容</desc>
          <html>&lt;iframe src="/index-blank.html" width="300" height="100"&gt;&lt;/iframe&gt;</html>
          <code>$("iframe").contents().find("body")
  .append("I'm in an iframe!");</code>
        </example>
      </function>
      <function name="end" return="JPlus">
        <desc>回到最近的一个"破坏性"操作之前。即，将匹配的元素列表变为前一次的状态。</desc>
        <longdesc>如果之前没有破坏性操作，则返回一个空集。所谓的"破坏性"就是指任何改变所匹配的JPlus元素的操作。这包括在 Traversing 中任何返回一个JPlus对象的函数--'add', 'andSelf', 'children', 'filter', 'find', 'map', 'next', 'nextAll', 'not', 'parent', 'parents', 'prev', 'prevAll', 'siblings' and 'slice'--再加上 Manipulation 中的 'clone'。</longdesc>
        <example>
          <desc>选取所有的p元素，查找并选取span子元素，然后再回过来选取p元素</desc>
          <html>&lt;p&gt;&lt;span&gt;Hello&lt;/span&gt;,how are you?&lt;/p&gt;</html>
          <code>$("p").find("span").end()</code>
          <result>[ &lt;p&gt;&lt;span&gt;Hello&lt;/span&gt; how are you?&lt;/p&gt; ]</result>
        </example>
      </function>
    </subcat>
  </cat>
  <cat value="文档处理">
    <subcat value="内部插入">
      <function name="append" return="JPlus">
        <desc>向每个匹配的元素内部追加内容。</desc>
        <longdesc>这个操作与对指定的元素执行appendChild方法，将它们添加到文档中的情况类似。</longdesc>
        <params name="content" type="String, Element, JPlus">
          <desc>要追加到目标中的内容</desc>
        </params>
        <example>
          <desc>向所有段落中追加一些HTML标记。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;</html>
          <code>$("p").append("&lt;b&gt;Hello&lt;/b&gt;");</code>
          <result>[ &lt;p&gt;I would like to say: &lt;b&gt;Hello&lt;/b&gt;&lt;/p&gt; ]</result>
        </example>
      </function>
      <function name="append" return="JPlus">
        <desc>JPlus 1.4 新增。向每个匹配的元素内部追加内容。</desc>
        <longdesc>这个操作与对指定的元素执行appendChild方法，将它们添加到文档中的情况类似。</longdesc>
        <params name="function(index, html)" type="Function">
          <desc>返回一个HTML字符串，用于追加到每一个匹配元素的里边。接受两个参数，index参数为对象在这个集合中的索引值，html参数为这个对象原先的html值。</desc>
        </params>
      </function>
      <function name="appendTo" return="JPlus">
        <desc>把所有匹配的元素追加到另一个指定的元素元素集合中。</desc>
        <longdesc>实际上，使用这个方法是颠倒了常规的$(A).append(B)的操作，即不是把B追加到A中，而是把A追加到B中。
		
		在JPlus 1.3.2中，appendTo, prependTo, insertBefore, insertAfter, 和 replaceAll这个几个方法成为一个破坏性操作，返回值是所有被追加的内容，而不仅仅是先前所选中的元素。所以，要选择先前选中的元素，需要使用end()方法，参见例二。</longdesc>
        <params name="content" type="String">
          <desc>用于被追加的内容</desc>
        </params>
        <example>
          <desc>把所有段落追加到ID值为foo的元素中。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;
&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;</html>
          <code>$("p").appendTo("div");</code>
          <result>&lt;div&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;/div&gt;
&lt;div&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;/div&gt;</result>
        </example>
        <example>
          <desc>新建段落追加div中并加上一个class</desc>
          <html>&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;</html>
          <code> $("&lt;p/&gt;")
   .appendTo("div")
   .addClass("test")
   .end()
   .addClass("test2");</code>
          <result>&lt;div&gt;&lt;p class="test test2"&gt;&lt;/p&gt;&lt;/div&gt;<br />
&lt;div&gt;&lt;p class="test"&gt;&lt;/p&gt;&lt;/div&gt;<br />
</result>
        </example>
      </function>
      <function name="prepend" return="JPlus">
        <desc>向每个匹配的元素内部前置内容。</desc>
        <longdesc>这是向所有匹配元素内部的开始处插入内容的最佳方式。</longdesc>
        <params name="content" type="String, Element, JPlus">
          <desc>要插入到目标元素内部前端的内容</desc>
        </params>
        <example>
          <desc>向所有段落中前置一些HTML标记代码。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;</html>
          <code>$("p").prepend("&lt;b&gt;Hello&lt;/b&gt;");</code>
          <result>[ &lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;I would like to say: &lt;/p&gt; ]</result>
        </example>
        <example>
          <desc>将一个DOM元素前置入所有段落</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;
&lt;p&gt;I would like to say: &lt;/p&gt;
&lt;b class="foo"&gt;Hello&lt;/b&gt;
&lt;b class="foo"&gt;Good Bye&lt;/b&gt;</html>
          <code>$("p").prepend( $(".foo")[0] );</code>
          <result>&lt;p&gt;&lt;b class="foo"&gt;Hello&lt;/b&gt;I would like to say: &lt;/p&gt;
&lt;p&gt;&lt;b class="foo"&gt;Hello&lt;/b&gt;I would like to say: &lt;/p&gt;
&lt;b class="foo"&gt;Hello&lt;/b&gt;
&lt;b class="foo"&gt;Good Bye&lt;/b&gt;</result>
        </example>
        <example>
          <desc>向所有段落中前置一个JPlus对象(类似于一个DOM元素数组)。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</html>
          <code>$("p").prepend( $("b") );</code>
          <result>&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;I would like to say: &lt;/p&gt;</result>
        </example>
      </function>
      <function name="prepend" return="JPlus">
        <desc>JPlus 1.4 新增。向每个匹配的元素内部最前面追加内容。</desc>
        <longdesc>这个操作与对指定的元素执行appendChild方法，将它们添加到文档中的情况类似。</longdesc>
        <params name="function(index, html)" type="Function">
          <desc>返回一个HTML字符串，用于追加到每一个匹配元素的里边。接受两个参数，index参数为对象在这个集合中的索引值，html参数为这个对象原先的html值。</desc>
        </params>
      </function>
      <function name="prependTo" return="JPlus">
        <desc>把所有匹配的元素前置到另一个、指定的元素元素集合中。</desc>
        <longdesc>实际上，使用这个方法是颠倒了常规的$(A).prepend(B)的操作，即不是把B前置到A中，而是把A前置到B中。

		在JPlus 1.3.2中，appendTo, prependTo, insertBefore, insertAfter, 和 replaceAll这个几个方法成为一个破坏性操作，要选择先前选中的元素，需要使用end()方法，参见 appendTo 方法的例二。</longdesc>
        <params name="content" type="String">
          <desc>用于匹配元素的JPlus表达式</desc>
        </params>
        <example>
          <desc>把所有段落追加到ID值为foo的元素中。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;div id="foo"&gt;&lt;/div&gt;</html>
          <code>$("p").prependTo("#foo");</code>
          <result>&lt;div id="foo"&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;/div&gt;</result>
        </example>
      </function>
    </subcat>
    <subcat value="外部插入">
      <function name="after" return="JPlus">
        <desc>在每个匹配的元素之后插入内容。</desc>
        <params name="content" type="String, Element, JPlus">
          <desc>插入到每个目标后的内容</desc>
        </params>
        <example>
          <desc>在所有段落之后插入一些HTML标记代码。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;</html>
          <code>$("p").after("&lt;b&gt;Hello&lt;/b&gt;");</code>
          <result>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</result>
        </example>
        <example>
          <desc>在所有段落之后插入一个DOM元素。</desc>
          <html>&lt;b id="foo"&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</html>
          <code>$("p").after( $("#foo")[0] );</code>
          <result>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b id="foo"&gt;Hello&lt;/b&gt;</result>
        </example>
        <example>
          <desc>在所有段落中后插入一个JPlus对象(类似于一个DOM元素数组)。</desc>
          <html>&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</html>
          <code>$("p").after( $("b") );</code>
          <result>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</result>
        </example>
      </function>
      <function name="after" return="JPlus">
        <desc>在每个匹配的元素之后插入内容。</desc>
        <params name="function" type="Function">
          <desc>JPlus 1.4 新增。函数必须返回一个html字符串。</desc>
        </params>
      </function>
      <function name="before" return="JPlus">
        <desc>在每个匹配的元素之前插入内容。</desc>
        <params name="content" type="String, Element, JPlus">
          <desc>插入到每个目标前的内容</desc>
        </params>
        <example>
          <desc>在所有段落之前插入一些HTML标记代码。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;</html>
          <code>$("p").before("&lt;b&gt;Hello&lt;/b&gt;");</code>
          <result>[ &lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt; ]</result>
        </example>
        <example>
          <desc>在所有段落之前插入一个元素。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b id="foo"&gt;Hello&lt;/b&gt;</html>
          <code>$("p").before( $("#foo")[0] );</code>
          <result>&lt;b id="foo"&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</result>
        </example>
        <example>
          <desc>在所有段落中前插入一个JPlus对象(类似于一个DOM元素数组)。</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt;</html>
          <code>$("p").before( $("b") );</code>
          <result>&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</result>
        </example>
      </function>
      <function name="before" return="JPlus">
        <desc>在每个匹配的元素之前插入内容。</desc>
        <params name="function" type="Function">
          <desc>JPlus 1.4 新增。函数必须返回一个html字符串。</desc>
        </params>
      </function>
      <function name="insertAfter" return="JPlus">
        <desc>把所有匹配的元素插入到另一个、指定的元素元素集合的后面。</desc>
        <longdesc>实际上，使用这个方法是颠倒了常规的$(A).after(B)的操作，即不是把B插入到A后面，而是把A插入到B后面。

		在JPlus 1.3.2中，appendTo, prependTo, insertBefore, insertAfter, 和 replaceAll这个几个方法成为一个破坏性操作，要选择先前选中的元素，需要使用end()方法，参见 appendTo 方法的例二。</longdesc>
        <params name="content" type="String">
          <desc>用于匹配元素的JPlus表达式</desc>
        </params>
        <example>
          <desc>把所有段落插入到一个元素之后。与 $("#foo").after("p")相同</desc>
          <html>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;div id="foo"&gt;Hello&lt;/div&gt;</html>
          <code>$("p").insertAfter("#foo");</code>
          <result>&lt;div id="foo"&gt;Hello&lt;/div&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</result>
        </example>
      </function>
      <function name="insertBefore" return="JPlus">
        <desc>把所有匹配的元素插入到另一个、指定的元素元素集合的前面。</desc>
        <longdesc>实际上，使用这个方法是颠倒了常规的$(A).before(B)的操作，即不是把B插入到A前面，而是把A插入到B前面。

		在JPlus 1.3.2中，appendTo, prependTo, insertBefore, insertAfter, 和 replaceAll这个几个方法成为一个破坏性操作，要选择先前选中的元素，需要使用end()方法，参见 appendTo 方法的例二。</longdesc>
        <params name="content" type="String">
          <desc>用于匹配元素的JPlus表达式</desc>
        </params>
        <example>
          <desc>把所有段落插入到一个元素之前。与 $("#foo").before("p")相同。</desc>
          <html>&lt;div id="foo"&gt;Hello&lt;/div&gt;&lt;p&gt;I would like to say: &lt;/p&gt;</html>
          <code>$("p").insertBefore("#foo");</code>
          <result>&lt;p&gt;I would like to say: &lt;/p&gt;&lt;div id="foo"&gt;Hello&lt;/div&gt;</result>
        </example>
      </function>
    </subcat>
    <subcat value="包裹">
      <function name="wrap" return="JPlus">
        <desc>把所有匹配的元素用其他元素的结构化标记包裹起来。</desc>
        <longdesc>这种包装对于在文档中插入额外的结构化标记最有用，而且它不会破坏原始文档的语义品质。这个函数的原理是检查提供的第一个元素（它是由所提供的HTML标记代码动态生成的），并在它的代码结构中找到最上层的祖先元素－－这个祖先元素就是包裹元素。当HTML标记代码中的元素包含文本时无法使用这个函数。因此，如果要添加文本应该在包裹完成之后再行添加。</longdesc>
        <params name="html" type="String">
          <desc>HTML标记代码字符串，用于动态生成元素并包裹目标元素</desc>
        </params>
        <example>
          <desc>把所有的段落用一个新创建的div包裹起来</desc>
          <html>&lt;p&gt;Test Paragraph.&lt;/p&gt;</html>
          <code>$("p").wrap("&lt;div class='wrap'&gt;&lt;/div&gt;");</code>
          <result>&lt;div class="wrap"&gt;&lt;p&gt;Test Paragraph.&lt;/p&gt;&lt;/div&gt;</result>
        </example>
      </function>
      <function name="wrap" return="JPlus">
        <desc>把所有匹配的元素用其他元素的结构化标记包装起来。</desc>
        <params name="elem" type="Element">
          <desc>用于包装目标元素的DOM元素</desc>
        </params>
        <example>
          <desc>用ID是"content"的div将每一个段落包裹起来</desc>
          <html>&lt;p&gt;Test Paragraph.&lt;/p&gt;&lt;div id="content"&gt;&lt;/div&gt;</html>
          <code>$("p").wrap(document.getElementById('content'));</code>
          <result>&lt;div id="content"&gt;&lt;p&gt;Test Paragraph.&lt;/p&gt;&lt;/div&gt;&lt;div id="content"&gt;&lt;/div&gt;</result>
        </example>
      </function>
      <function name="wrap" return="JPlus">
        <desc>把所有匹配的元素用其他元素的结构化标记包装起来。</desc>
        <params name="fn" type="Function">
          <desc>生成包裹结构的一个函数</desc>
        </params>
        <example>
          <desc>用原先div的内容作为新div的class，并将每一个元素包裹起来</desc>
          <html>&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;inner&quot;&gt;Hello&lt;/div&gt;
  &lt;div class=&quot;inner&quot;&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</html>
          <code>$('.inner').wrap(function() {
  return '&lt;div class=&quot;' + $(this).text() + '&quot; /&gt;';
});</code>
          <result>&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;Hello&quot;&gt;
    &lt;div class=&quot;inner&quot;&gt;Hello&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;Goodbye&quot;&gt;
    &lt;div class=&quot;inner&quot;&gt;Goodbye&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</result>
        </example>
      </function>
      <function name="unwrap" return="JPlus">
        <desc>这个方法将移出元素的父元素。这能快速取消 .wrap()方法的效果。匹配的元素（以及他们的同辈元素）会在DOM结构上替换他们的父元素。</desc>
        <example>
          <desc>用ID是"content"的div将每一个段落包裹起来</desc>
          <html>&lt;div&gt;
    &lt;p&gt;Hello&lt;/p&gt;
    &lt;p&gt;cruel&lt;/p&gt;
    &lt;p&gt;World&lt;/p&gt;
&lt;/div&gt;</html>
          <code> $("p").unwrap()</code>
          <result>    &lt;p&gt;Hello&lt;/p&gt;
    &lt;p&gt;cruel&lt;/p&gt;
    &lt;p&gt;World&lt;/p&gt;</result>
        </example>
      </function>
      <function name="wrapAll" return="JPlus">
        <desc>将所有匹配的元素用单个元素包裹起来</desc>
        <longdesc>这于 '.wrap()'&lt;a href="http://docs.jquery.com/Manipulation/wrap" title="Manipulation/wrap"&gt;&lt;/a&gt; 是不同的，'.wrap()'为每一个匹配的元素都包裹一次。这种包装对于在文档中插入额外的结构化标记最有用，而且它不会破坏原始文档的语义品质。这个函数的原理是检查提供的第一个元素并在它的代码结构中找到最上层的祖先元素－－这个祖先元素就是包装元素。</longdesc>
        <params name="html" type="String">
          <desc>TML标记代码字符串，用于动态生成元素并包装目标元素</desc>
        </params>
        <example>
          <desc>用一个生成的div将所有段落包裹起来</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;</html>
          <code>$("p").wrapAll("&lt;div&gt;&lt;/div&gt;");</code>
          <result>&lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;&lt;/div&gt;</result>
        </example>
      </function>
      <function name="wrapAll" return="JPlus">
        <desc>将所有匹配的元素用单个元素包裹起来</desc>
        <longdesc>这于 '.wrap()'&lt;a href="http://docs.jquery.com/Manipulation/wrap" title="Manipulation/wrap"&gt;&lt;/a&gt; 是不同的，'.wrap()'为每一个匹配的元素都包裹一次。</longdesc>
        <params name="elem" type="Element">
          <desc>用于包装目标元素的DOM元素</desc>
        </params>
        <example>
          <desc>用一个生成的div将所有段落包裹起来</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;</html>
          <code>$("p").wrapAll(document.createElement("div"));</code>
          <result>&lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;&lt;/div&gt;</result>
        </example>
      </function>
      <function name="wrapInner" return="JPlus">
        <desc>将每一个匹配的元素的子内容(包括文本节点)用一个HTML结构包裹起来</desc>
        <longdesc>这个函数的原理是检查提供的第一个元素（它是由所提供的HTML标记代码动态生成的），并在它的代码结构中找到最上层的祖先元素－－这个祖先元素就是包装元素。</longdesc>
        <params name="html" type="String">
          <desc>HTML标记代码字符串，用于动态生成元素并包装目标元素</desc>
        </params>
        <example>
          <desc>把所有段落内的每个子内容加粗</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;</html>
          <code>$("p").wrapInner("&lt;b&gt;&lt;/b&gt;");</code>
          <result>&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;cruel&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;World&lt;/b&gt;&lt;/p&gt;</result>
        </example>
      </function>
      <function name="wrapInner" return="JPlus">
        <desc>将每一个匹配的元素的子内容(包括文本节点)用DOM元素包裹起来</desc>
        <params name="elem" type="Element">
          <desc>用于包装目标元素的DOM元素</desc>
        </params>
        <example>
          <desc>把所有段落内的每个子内容加粗</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;</html>
          <code>$("p").wrapInner(document.createElement("b"));</code>
          <result>&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;cruel&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;World&lt;/b&gt;&lt;/p&gt;</result>
        </example>
      </function>
      <function name="wrapInner" return="JPlus">
        <desc>将每一个匹配的元素的子内容(包括文本节点)用DOM元素包裹起来</desc>
        <params name="fn" type="Function">
          <desc>生成包裹结构的一个函数</desc>
        </params>
        <example>
          <desc>用原先div的内容作为新div的class，并将每一个元素包裹起来</desc>
          <html>&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;inner&quot;&gt;Hello&lt;/div&gt;
  &lt;div class=&quot;inner&quot;&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</html>
          <code>$('.inner').wrapInner(function() {
  return '&lt;div class=&quot;' + $(this).text() + '&quot; /&gt;';
});</code>
          <result>&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;inner&quot;&gt;
    &lt;div class=&quot;Hello&quot;&gt;Hello&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;inner&quot;&gt;
    &lt;div class=&quot;Goodbye&quot;&gt;Goodbye&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</result>
        </example>
      </function>
    </subcat>
    <subcat value="替换">
      <function name="replaceWith" return="JPlus">
        <desc>将所有匹配的元素替换成指定的HTML或DOM元素。</desc>
        <params name="content" type="String, Element, JPlus, Function">
          <desc>用于将匹配元素替换掉的内容。如果这里传递一个函数进来的话，函数返回值必须是HTML字符串。</desc>
        </params>
        <example>
          <desc>把所有的段落标记替换成加粗的标记。</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;</html>
          <code>$("p").replaceWith("&lt;b&gt;Paragraph. &lt;/b&gt;");</code>
          <result>&lt;b&gt;Paragraph. &lt;/b&gt;&lt;b&gt;Paragraph. &lt;/b&gt;&lt;b&gt;Paragraph. &lt;/b&gt;</result>
        </example>
        <example>
          <desc>用第一段替换第三段，你可以发现他是移动到目标位置来替换，而不是复制一份来替换。</desc>
          <html>&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;inner first&quot;&gt;Hello&lt;/div&gt;
  &lt;div class=&quot;inner second&quot;&gt;And&lt;/div&gt;
  &lt;div class=&quot;inner third&quot;&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</html>
          <code>$('.third').replaceWith($('.first'));</code>
          <result>&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;inner second&quot;&gt;And&lt;/div&gt;
  &lt;div class=&quot;inner first&quot;&gt;Hello&lt;/div&gt;
&lt;/div&gt;</result>
        </example>
      </function>
      <function name="replaceAll" return="JPlus">
        <desc>用匹配的元素替换掉所有 selector匹配到的元素。</desc>
		<longdesc>在JPlus 1.3.2中，appendTo, prependTo, insertBefore, insertAfter, 和 replaceAll这个几个方法成为一个破坏性操作，要选择先前选中的元素，需要使用end()方法，参见 appendTo 方法的例二。</longdesc>
        <params name="selector" type="选择器">
          <desc>用于查找所要被替换的元素</desc>
        </params>
        <example>
          <desc>把所有的段落标记替换成加粗标记</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;</html>
          <code>$("&lt;b&gt;Paragraph. &lt;/b&gt;").replaceAll("p");</code>
          <result>&lt;b&gt;Paragraph. &lt;/b&gt;&lt;b&gt;Paragraph. &lt;/b&gt;&lt;b&gt;Paragraph. &lt;/b&gt;</result>
        </example>
      </function>
    </subcat>
    <subcat value="删除">
      <function name="empty" return="JPlus">
        <desc>删除匹配的元素集合中所有的子节点。</desc>
        <example>
          <desc>把所有段落的子元素（包括文本节点）删除</desc>
          <html>&lt;p&gt;Hello, &lt;span&gt;Person&lt;/span&gt; &lt;a href="#"&gt;and person&lt;/a&gt;&lt;/p&gt;</html>
          <code>$("p").empty();</code>
          <result>&lt;p&gt;&lt;/p&gt;</result>
        </example>
      </function>
      <function name="remove" return="JPlus">
        <desc>从DOM中删除所有匹配的元素。</desc>
        <longdesc>这个方法不会把匹配的元素从JPlus对象中删除，因而可以在将来再使用这些匹配的元素。但除了这个元素本身得以保留之外，其他的比如绑定的事件，附加的数据等都会被移除。</longdesc>
        <params name="expr" type="String" optional="true">
          <desc>用于筛选元素的JPlus表达式</desc>
        </params>
        <example>
          <desc>从DOM中把所有段落删除</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt;</html>
          <code>$("p").remove();</code>
          <result>how are</result>
        </example>
        <example>
          <desc>从DOM中把带有hello类的段落删除</desc>
          <html>&lt;p class="hello"&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt;</html>
          <code>$("p").remove(".hello");</code>
          <result>how are &lt;p&gt;you?&lt;/p&gt;</result>
        </example>
      </function>
      <function name="detach" return="JPlus">
        <desc>从DOM中删除所有匹配的元素。</desc>
        <longdesc>这个方法不会把匹配的元素从JPlus对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。</longdesc>
        <params name="expr" type="String" optional="true">
          <desc>用于筛选元素的JPlus表达式</desc>
        </params>
        <example>
          <desc>从DOM中把所有段落删除</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt;</html>
          <code>$("p").detach();</code>
          <result>how are</result>
        </example>
        <example>
          <desc>从DOM中把带有hello类的段落删除</desc>
          <html>&lt;p class="hello"&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt;</html>
          <code>$("p").detach(".hello");</code>
          <result>how are &lt;p&gt;you?&lt;/p&gt;</result>
        </example>
      </function>
    </subcat>
    <subcat value="复制">
      <function name="clone" return="JPlus">
        <desc>克隆匹配的DOM元素并且选中这些克隆的副本。</desc>
        <longdesc>在想把DOM文档中元素的副本添加到其他位置时这个函数非常有用。</longdesc>
        <example>
          <desc>克隆所有b元素（并选中这些克隆的副本），然后将它们前置到所有段落中。</desc>
          <html>&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;, how are you?&lt;/p&gt;</html>
          <code>$("b").clone().prependTo("p");</code>
          <result>&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;, how are you?&lt;/p&gt;</result>
        </example>
      </function>
      <function name="clone" return="JPlus">
        <desc>元素以及其所有的事件处理并且选中这些克隆的副本</desc>
        <longdesc>在想把DOM文档中元素的副本添加到其他位置时这个函数非常有用。</longdesc>
        <params name="true" type="Boolean">
          <desc>设置为true以便复制元素的所有事件处理</desc>
        </params>
        <example>
          <desc>创建一个按钮，他可以复制自己，并且他的副本也有同样功能。</desc>
          <html>&lt;button&gt;Clone Me!&lt;/button&gt;</html>
          <code>$("button").click(function(){
  $(this).clone(true).insertAfter(this);
});</code>
        </example>
      </function>
    </subcat>
  </cat>
  <cat value="CSS">
    <subcat value="CSS">
      <function name="css" return="String">
        <desc>访问第一个匹配元素的样式属性。</desc>
        <params name="name" type="String">
          <desc>要访问的属性名称</desc>
        </params>
        <example>
          <desc>取得第一个段落的color样式属性的值。</desc>
          <code>$("p").css("color");</code>
        </example>
      </function>
      <function name="css" return="JPlus">
        <desc>把一个“名/值对”对象设置为所有匹配元素的样式属性。</desc>
        <longdesc>这是一种在所有匹配的元素上设置大量样式属性的最佳方式。</longdesc>
        <params name="properties" type="Map">
          <desc>要设置为样式属性的名/值对</desc>
        </params>
        <example>
          <desc>将所有段落的字体颜色设为红色并且背景为蓝色。</desc>
          <code>$("p").css({ color: "#ff0011", background: "blue" });</code>
        </example>
        <example>
          <desc>如果属性名包含 "-"的话，必须使用引号:</desc>
          <code>$("p").css({ "margin-left": "10px", "background-color": "blue" });</code>
        </example>
      </function>
      <function name="css" return="JPlus">
        <desc>在所有匹配的元素中，设置一个样式属性的值。</desc>
        <longdesc>数字将自动转化为像素值</longdesc>
        <params name="name" type="value">
          <desc>属性名</desc>
        </params>
        <params name="value" type="String, Number">
          <desc>属性值</desc>
        </params>
        <example>
          <desc>将所有段落字体设为红色</desc>
          <code>$("p").css("color","red");</code>
        </example>
      </function>
      <function name="css" return="JPlus">
        <desc>在所有匹配的元素中，设置一个样式属性的值。</desc>
        <longdesc>数字将自动转化为像素值</longdesc>
        <params name="name" type="value">
          <desc>属性名</desc>
        </params>
        <params name="function(index, value)" type="Function">
          <desc>此函数返回要设置的属性值。接受两个参数，index为元素在对象集合中的索引位置，value是原先的属性值。</desc>
        </params>
        <example>
          <desc>逐渐增加div的大小</desc>
          <code>  $("div").click(function() {
    $(this).css({
      width: function(index, value) {
        return parseFloat(value) * 1.2;
      }, 
      height: function(index, value) {
        return parseFloat(value) * 1.2;
      }

    });
  });</code>
        </example>
      </function>
    </subcat>
    <subcat value="位置">
      <function name="offset" return="Object{top,left}">
        <desc>获取匹配元素在当前视口的相对偏移。</desc>
        <longdesc>返回的对象包含两个整型属性：top 和 left。此方法只对可见元素有效。</longdesc>
        <example>
          <desc>获取第二段的偏移</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt;</html>
          <code>var p = $("p:last");
var offset = p.offset();
p.html( "left: " + offset.left + ", top: " + offset.top );</code>
          <result>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;left: 0, top: 35&lt;/p&gt;</result>
        </example>
      </function>
      <function name="offset" return="JPlus">
        <desc>设置匹配元素相对于document对象的坐标。</desc>
        <longdesc>.offset()方法可以让我们重新设置元素的位置。这个元素的位置是相对于document对象的。如果对象原先的position样式属性是static的话，会被改成relative来实现重定位。</longdesc>
        <params name="coordinates" type="Object{top,left}, function(index, coords) ">
          <desc>一个对象，必须包含top和left属性，作为元素的新坐标。这个参数也可以是一个返回一对坐标的函数，函数的第一个参数是元素的索引，第二个参数是当前的坐标。</desc>
        </params>
        <example>
          <desc>获取第二段的偏移</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt;</html>
          <code>$("p:last").offset({ top: 10, left: 30 });</code>
        </example>
      </function>
      <function name="position" return="Object{top,left}">
        <desc>获取匹配元素相对父元素的偏移。</desc>
        <longdesc>返回的对象包含两个整型属性：top 和 left。为精确计算结果，请在补白、边框和填充属性上使用像素单位。此方法只对可见元素有效。</longdesc>
        <example>
          <desc>获取第一段的偏移</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt;</html>
          <code>var p = $("p:first");
var position = p.position();
$("p:last").html( "left: " + position.left + ", top: " + position.top );</code>
          <result>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;left: 15, top: 15&lt;/p&gt;</result>
        </example>
      </function>
      <function name="scrollTop" return="Integer">
        <desc>获取匹配元素相对滚动条顶部的偏移。</desc>
        <longdesc>此方法对可见和隐藏元素均有效。</longdesc>
        <example>
          <desc>获取第一段相对滚动条顶部的偏移</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt;</html>
          <code>var p = $("p:first");
$("p:last").text( "scrollTop:" + p.scrollTop() );</code>
          <result>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;scrollTop: 0&lt;/p&gt;</result>
        </example>
      </function>
      <function name="scrollTop" return="JPlus">
        <desc>传递参数值时，设置垂直滚动条顶部偏移为该值。</desc>
        <longdesc>此方法对可见和隐藏元素均有效。</longdesc>
        <params name="val" type="String, Number">
          <desc>设定垂直滚动条值</desc>
        </params>
        <example>
          <desc>设置相对滚动条顶部的偏移</desc>
          <code>$("div.demo").scrollTop(300);</code>
        </example>
      </function>
      <function name="scrollLeft" return="Integer">
        <desc>获取匹配元素相对滚动条左侧的偏移。</desc>
        <longdesc>此方法对可见和隐藏元素均有效。</longdesc>
        <example>
          <desc>获取第一段相对滚动条左侧的偏移</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt;</html>
          <code>var p = $("p:first");
$("p:last").text( "scrollLeft:" + p.scrollLeft() );</code>
          <result>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;scrollLeft: 0&lt;/p&gt;</result>
        </example>
      </function>
      <function name="scrollLeft" return="JPlus">
        <desc>传递参数值时，设置水平滚动条左侧偏移为该值。</desc>
        <longdesc>此方法对可见和隐藏元素均有效。</longdesc>
        <params name="val" type="String, Number">
          <desc>设定水平滚动条值</desc>
        </params>
        <example>
          <desc>设置相对滚动条左侧的偏移</desc>
          <code>$("div.demo").scrollLeft(300);</code>
        </example>
      </function>
    </subcat>
    <subcat value="尺寸">
      <function name="height" return="Integer">
        <desc>取得第一个匹配元素当前计算的高度值（px）。</desc>
        <longdesc>在 JPlus 1.2 以后可以用来获取 window 和 document 的高</longdesc>
        <example>
          <desc>获取第一段的高</desc>
          <code>$("p").height();</code>
        </example>
        <example>
          <desc>获取当前浏览器窗口的高度</desc>
          <code>$(window).height();</code>
        </example>
        <example>
          <desc>获取当前HTML文档高度</desc>
          <code>$(document).height();</code>
        </example>
      </function>
      <function name="height" return="JPlus">
        <desc>为每个匹配的元素设置CSS高度(hidth)属性的值。如果没有明确指定单位（如：em或%），使用px。</desc>
        <longdesc>如果没有明确指定单位（如：em或%），使用px。</longdesc>
        <params name="val" type="String, Number, Function">
          <desc>设定CSS中 'height' 的值，可以是字符串或者数字，还可以是一个函数，返回要设置的数值。函数接受两个参数，第一个参数是元素在原先集合中的索引位置，第二个参数为原先的高度。</desc>
        </params>
        <example>
          <desc>把所有段落的高设为 20:</desc>
          <code>$("p").height(20);</code>
        </example>
      </function>
      <function name="width" return="Integer">
        <desc>取得第一个匹配元素当前计算的宽度值（px）。</desc>
        <longdesc>在 JPlus 1.2 以后可以用来获取 window 和 document 的宽</longdesc>
        <example>
          <desc>获取第一段的宽</desc>
          <code>$("p").width();</code>
        </example>
        <example>
          <desc>获取当前浏览器窗口的宽度</desc>
          <code>$(window).width();</code>
        </example>
        <example>
          <desc>获取当前HTML文档宽度</desc>
          <code>$(document).width();</code>
        </example>
      </function>
      <function name="width" return="JPlus">
        <desc>为每个匹配的元素设置CSS宽度(width)属性的值。</desc>
        <longdesc>如果没有明确指定单位（如：em或%），使用px。</longdesc>
        <params name="val" type="String, Number, Function">
          <desc>设定 CSS 'width' 的属性值，可以是字符串或者数字，还可以是一个函数，返回要设置的数值。函数接受两个参数，第一个参数是元素在原先集合中的索引位置，第二个参数为原先的宽度。</desc>
        </params>
        <example>
          <desc>将所有段落的宽设为 20:</desc>
          <code>$("p").width(20);</code>
        </example>
      </function>
      <function name="innerHeight" return="Integer">
        <desc>获取第一个匹配元素内部区域高度（包括补白、不包括边框）。</desc>
        <longdesc>此方法对可见和隐藏元素均有效。</longdesc>
        <example>
          <desc>获取第一段落内部区域高度。</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt;</html>
          <code>var p = $("p:first");
$("p:last").text( "innerHeight:" + p.innerHeight() );</code>
          <result>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;innerHeight: 16&lt;/p&gt;</result>
        </example>
      </function>
      <function name="innerWidth" return="Integer">
        <desc>获取第一个匹配元素内部区域宽度（包括补白、不包括边框）。</desc>
        <longdesc>此方法对可见和隐藏元素均有效。</longdesc>
        <example>
          <desc>获取第一段落内部区域宽度。</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt;</html>
          <code>var p = $("p:first");
$("p:last").text( "innerWidth:" + p.innerWidth() );</code>
          <result>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;innerWidth: 40&lt;/p&gt;</result>
        </example>
      </function>
      <function name="outerHeight" return="Integer">
        <desc>获取第一个匹配元素外部高度（默认包括补白和边框）。</desc>
        <longdesc>此方法对可见和隐藏元素均有效。</longdesc>
        <params name="options" type="Boolean" default="false">
          <desc>设置为 true 时，计算边距在内。</desc>
        </params>
        <example>
          <desc>获取第一段落外部高度。</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt;</html>
          <code>var p = $("p:first");
$("p:last").text( "outerHeight:" + p.outerHeight() + " , outerHeight(true):" + p.outerHeight(true) );</code>
          <result>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;outerHeight: 35 , outerHeight(true):55&lt;/p&gt;</result>
        </example>
      </function>
      <function name="outerWidth" return="Integer">
        <desc>获取第一个匹配元素外部宽度（默认包括补白和边框）。</desc>
        <longdesc>此方法对可见和隐藏元素均有效。</longdesc>
        <params name="options" type="Boolean" default="false">
          <desc>设置为 true 时，计算边距在内。</desc>
        </params>
        <example>
          <desc>获取第一段落外部宽度。</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;2nd Paragraph&lt;/p&gt;</html>
          <code>var p = $("p:first");
$("p:last").text( "outerWidth:" + p.outerWidth() + " , outerWidth(true):" + p.outerWidth(true) );</code>
          <result>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;outerWidth: 65 , outerWidth(true):85&lt;/p&gt;</result>
        </example>
      </function>
    </subcat>
  </cat>
  <cat value="事件">
    <subcat value="页面载入">
      <function name="ready" return="JPlus">
        <desc>当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。</desc>
        <longdesc>这是事件模块中最重要的一个函数，因为它可以极大地提高web应用程序的响应速度。

简单地说，这个方法纯粹是对向window.load事件注册事件的替代方法。通过使用这个方法，可以在DOM载入就绪能够读取并操纵时立即调用你所绑定的函数，而99.99%的JavaScript函数都需要在那一刻执行。

有一个参数－－对JPlus函数的引用－－会传递到这个ready事件处理函数中。可以给这个参数任意起一个名字，并因此可以不再担心命名冲突而放心地使用$别名。

请确保在 &lt;body&gt; 元素的onload事件中没有注册函数，否则不会触发$(document).ready()事件。

可以在同一个页面中无限次地使用$(document).ready()事件。其中注册的函数会按照（代码中的）先后顺序依次执行。</longdesc>
        <params name="fn" type="Function">
          <desc>要在DOM就绪时执行的函数</desc>
        </params>
        <example>
          <desc>在DOM加载完成时运行的代码，可以这样写：</desc>
          <code>$(document).ready(function(){
  // 在这里写你的代码...
});</code>
        </example>
        <example>
          <desc>使用 $(document).ready() 的简写，同时内部的 JPlus 代码依然使用 $ 作为别名，而不管全局的 $ 为何。</desc>
          <code>JPlus(function($) {
  // 你可以在这里继续使用$作为别名...
});</code>
        </example>
      </function>
    </subcat>
    <subcat value="事件处理">
      <function name="bind" return="JPlus">
        <desc>为每个匹配元素的特定事件绑定事件处理函数。</desc>
        <longdesc>.bind() 方法是用于往文档上附加行为的主要方式。所有JavaScript事件对象，比如focus, mouseover, 和 resize，都是可以作为type参数传递进来的。
		
JPlus还提供了一些绑定这些标准事件类型的简单方式，比如.click()用于简化.bind('click')。一共有以下这些：blur, focus, focusin, focusout, load, resize, scroll, unload, click, dblclick, mousedown, mouseup, mousemove, mouseover, mouseout, mouseenter, mouseleave, change, select, submit, keydown, keypress, keyup, error 。

任何作为type参数的字符串都是合法的；如果一个字符串不是原生的JavaScript事件名，那么这个事件处理函数会绑定到一个自定义事件上。这些自定义事件绝对不会由浏览器触发，但可以通过使用.trigger()或者.triggerHandler()在其他代码中手动触发。

如果type参数的字符串中包含一个点(.)字符，那么这个事件就看做是有命名空间的了。这个点字符就用来分隔事件和他的命名空间。举例来说，如果执行 .bind('click.name', handler) ，那么字符串中的 click 是事件类型，而字符串 name 就是命名空间。命名空间允许我们取消绑定或者触发一些特定类型的事件，而不用触发别的事件。参考unbind()来获取更多信息。

当一个事件传到一个元素上，所有绑定在上面的针对哪个事件的处理函数都会触发。如果注册了多个事件处理函数，总是按照绑定的顺序依次触发。当所有绑定的事件处理函数执行完毕后，事件继续沿着普通的事件冒泡途径上浮。

.bind()最基本的用法是：

&lt;pre&gt;
$('#foo').bind('click', function() {
  alert('User clicked on &quot;foo.&quot;');
});
&lt;/pre&gt;

这个代码能使ID为foo的元素响应click事件。当用户点击元素内部之后，就会弹出一个警告框。

'''多个事件'''

依次可以绑定多个事件类型，每个事件类型用空格分隔：

&lt;pre&gt;
$('#foo').bind('mouseenter mouseleave', function() {
  $(this).toggleClass('entered');
});
&lt;/pre&gt;

这个代码让一个&amp;lt;div id=&quot;foo&quot;&amp;gt;元素（初始情况下class没有设置成entered），当鼠标移进去的时候，在class中加上entered，而当鼠标移出这个div的时候，则去除这个class值。

在JPlus 1.4中，我们也可以通过传入一个映射对来一次绑定多个事件处理函数：

&lt;pre&gt;
$('#foo').bind({
  click: function() {
    // do something on click
  },
  mouseenter: function() {
    // do something on mouseenter
  }
});
&lt;/pre&gt;

'''事件处理函数'''

fn这个参数接受一个回调函数，就像先前展示的那样。在这个事件处理函数内部，this指向这个函数绑定的DOM元素。如果要让这个元素变成JPlus对象来使用JPlus的方法，可以把这个对象传入 $() 重新封装。比如说：

&lt;pre&gt;$('#foo').bind('click', function() {
  alert($(this).text());
});
&lt;/pre&gt;

这个代码执行之后，当用户点击了ID为foo的元素内部之后，他的文本内容就会出现在一个警告框中。

'''事件对象'''

fn这个参数的回调函数还可以接受一个参数。当这个函数被调用时，一个JavaScript事件对象会作为一个参数传进来。

这个事件对象通常是没有必要且可以省略的参数，因为当这个事件处理函数绑定的时候就能够明确知道他在触发的时候应该做些什么，通常就已经可以获得充分的信息了。然而在有些时候，在事件初始化的时候需要获取更多关于用户环境的信息。可以参考完整的关于&lt;a href=&quot;/category/events/event-object/&quot;&gt;事件对象&lt;/a&gt;的内容（英文）。

在事件处理函数内返回false就等价于执行事件对象上的.preventDefault()和.stopPropagation()。

可以像这样在事件处理函数内使用事件对象：

&lt;pre&gt;$(document).ready(function() {
  $('#foo').bind('click', function(event) {
    alert('The mouse cursor is at ('
      + event.pageX + ', ' + event.pageY + ')');
  });
});
&lt;/pre&gt;

注意，这个参数添加到了一个匿名函数上。这个代码可以让用户在点击ID为foo的元素时，报告鼠标点击时相对于页面的坐标。

'''传递事件数据'''

可选的第二个参数data通常用的很少。如果提供了这个参数，那么我们就能把一些附加信息传递给事件处理函数了。这个参数有个很好的用处，就是处理闭包带来的问题。比如我们有两个事件处理函数要指向同一个内部变量：

&lt;pre&gt;var message = 'Spoon!';
$('#foo').bind('click', function() {
  alert(message);
});
message = 'Not in the face!';
$('#bar').bind('click', function() {
  alert(message);
});
&lt;/pre&gt;

由于这两个函数在他们各自的环境中都有message，所以触发时显示的消息都是 Not in the face! 。变量值被改变了。为了回避这个问题，我们可以把message变量作为data参数传递进去：

&lt;pre&gt;var message = 'Spoon!';
$('#foo').bind('click', {msg: message}, function(event) {
  alert(event.data.msg);
});
message = 'Not in the face!';
$('#bar').bind('click', {msg: message}, function(event) {
  alert(event.data.msg);
});
&lt;/pre&gt;

这时在函数内部不再直接指向这个变量了；取而代之的是按值传递给了data参数，他能保持绑定事件时的值。第一个函数现在会显示Spoon!，而第二个则显示Not in the face!

注意，如果这个对象按引用传递给了函数，那么将会使情况变得极其复杂。

另外，可以参考.trigger()方法来了解如何在事件触发时传递数据，而不是在事件绑定的时候传递数据。

在JPlus 1.4中，不再支持把数据以及事件附加到一个object、embed或者applet元素上面。因为当往Java applet元素上附加数据时，会触发一个严重错误警告。
		</longdesc>
        <params name="type" type="String">
          <desc>含有一个或多个事件类型的字符串，比如"click"或"submit"，还可以是自定义事件名。</desc>
        </params>
        <params name="data" type="Object" optional="true">
          <desc>作为event.data属性值传递给事件对象的额外数据对象</desc>
        </params>
        <params name="fn" type="Function">
          <desc>绑定到每个匹配元素的事件上面的处理函数</desc>
        </params>
        <example>
          <desc>当每个段落被点击的时候，弹出其文本。</desc>
          <code>$("p").bind("click", function(){
  alert( $(this).text() );
});</code>
        </example>
        <example>
          <desc>你可以在事件处理之前传递一些附加的数据。</desc>
          <code>function handler(event) {
  alert(event.data.foo);
}
$("p").bind("click", {foo: "bar"}, handler)</code>
        </example>
        <example>
          <desc>通过返回false来取消默认的行为并阻止事件起泡。</desc>
          <code>$("form").bind("submit", function() { return false; })</code>
        </example>
        <example>
          <desc>通过使用 preventDefault() 方法只取消默认的行为。</desc>
          <code>$("form").bind("submit", function(event){
  event.preventDefault();
});</code>
        </example>
        <example>
          <desc>通过使用 stopPropagation() 方法只阻止一个事件起泡。</desc>
          <code>$("form").bind("submit", function(event){
  event.stopPropagation();
});</code>
        </example>
      </function>
      <function name="bind" return="JPlus">
        <desc>为每一个匹配元素一个或多个事件绑定事件处理器函数。</desc>
        <params name="map" type="Map">
          <desc>一次可以绑定多个事件。</desc>
        </params>
        <example>
          <desc>一次绑定click和mouseenter事件。</desc>
          <code>$('#foo').bind({
  click: function() {
    // do something on click
  },
  mouseenter: function() {
    // do something on mouseenter
  }
});</code>
        </example>
      </function>
      <function name="one" return="JPlus">
        <desc>为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数。</desc>
        <longdesc>在每个对象上，这个事件处理函数只会被执行一次。其他规则与bind()函数相同。这个事件处理函数会接收到一个事件对象，可以通过它来阻止（浏览器）默认的行为。如果既想取消默认的行为，又想阻止事件起泡，这个事件处理函数必须返回false。

多数情况下，可以把事件处理函数定义为匿名函数（见示例一）。在不可能定义匿名函数的情况下，可以传递一个可选的数据对象作为第二个参数（而事件处理函数则作为第三个参数），见示例二。</longdesc>
        <params name="type" type="String">
          <desc>事件类型</desc>
        </params>
        <params name="data" type="Object" optional="true">
          <desc>作为event.data属性值传递给事件对象的额外数据对象</desc>
        </params>
        <params name="fn" type="Function">
          <desc>绑定到每个匹配元素的事件上面的处理函数</desc>
        </params>
        <example>
          <desc>当所有段落被第一次点击的时候，显示所有其文本。</desc>
          <code>$("p").one("click", function(){
  alert( $(this).text() );
});</code>
        </example>
      </function>
      <function name="trigger" return="JPlus">
        <desc>在每一个匹配的元素上触发某类事件。</desc>
        <longdesc>这个函数也会导致浏览器同名的默认行为的执行。比如，如果用trigger()触发一个'submit'，则同样会导致浏览器提交表单。如果要阻止这种默认行为，应返回false。

你也可以触发由bind()注册的自定义事件而不限于浏览器默认事件。

事件处理函数会收到一个修复的(规范化的)事件对象，但这个对象没有特定浏览器才有的属性，比如keyCode。

JPlus也支持 &lt;a href="http://docs.jquery.com/Namespaced_Events"&gt;命名空间事件&lt;/a&gt;。这允许你触发或者解除绑定一组特定的事件处理函数，而无需一一个指定。你可以在事件类型后面加上感叹号 ! 来只触发那些没有命名空间的事件处理函数。

'''JPlus 1.3中新增：'''

所有触发的事件现在会冒泡到DOM树上了。举例来说，如果你在一个段落p上触发一个事件，他首先会在这个元素上触发，其次到父元素，在到父元素的父元素，直到触发到document对象。这个事件对象有一个 .target 属性指向最开始触发这个事件的元素。你可以用 stopPropagation() 来阻止事件冒泡，或者在事件处理函数中返回false即可。

事件对象构造器现在已经公开，并且你可以自行创建一个事件对象。这个事件对象可以直接传递给trigger所触发的事件处理函数。事件对象的完整属性列表可以在 &lt;a href="http://docs.jquery.com/Events/JPlus.Event"&gt;JPlus.Event&lt;/a&gt; 的文档里找到。

你可以有三种方式指定事件类型：

* 你可以传递字符串型的事件名称(type参数)。

* 你可以使用JPlus.Event对象。可以将数据放进这个对象，并且这个对象可以被触发的事件处理函数获取到。

* 最后，你可以传递一个带有数据的字面量对象。他将被复制到真正的JPlus.Event对象上去。 注意在这种情况下你'''必须'''指定一个 &lt;em&gt;type&lt;/em&gt; 属性。</longdesc>
        <params name="type" type="String,Event,Object">
          <desc>一个事件对象或者要触发的事件类型</desc>
        </params>
        <params name="data" type="Array" optional="true">
          <desc>(可选)传递给事件处理函数的附加参数</desc>
        </params>
        <example>
          <desc>提交第一个表单，但不用submit()</desc>
          <code>$("form:first").trigger("submit")</code>
        </example>
        <example>
          <desc>给一个事件传递参数</desc>
          <code>$("p").click( function (event, a, b) {
  // 一个普通的点击事件时，a和b是undefined类型
  // 如果用下面的语句触发，那么a指向"foo",而b指向"bar"
} ).trigger("click", ["foo", "bar"]);</code>
        </example>
        <example>
          <desc>下面的代码可以显示一个"Hello World"</desc>
          <code>$("p").bind("myEvent", function (event, message1, message2) {
  alert(message1 + ' ' + message2);
});
$("p").trigger("myEvent", ["Hello","World!"]);</code>
        </example>
      </function>
      <function name="triggerHandler" return="JPlus">
        <desc>这个特别的方法将会触发指定的事件类型上所有绑定的处理函数。但不会执行浏览器默认动作，也不会产生事件冒泡。</desc>
        <longdesc>这个方法的行为表现与trigger类似，但有以下三个主要区别： 
		
* 第一，他不会触发浏览器默认事件。

* 第二，只触发JPlus对象集合中第一个元素的事件处理函数。

* 第三，这个方法的返回的是事件处理函数的返回值，而不是据有可链性的JPlus对象。此外，如果最开始的JPlus对象集合为空，则这个方法返回 undefined 。</longdesc>
        <params name="type" type="String">
          <desc>要触发的事件类型</desc>
        </params>
        <params name="data" type="Array" optional="true">
          <desc>(可选)传递给事件处理函数的附加参数</desc>
        </params>
        <example>
          <desc>如果你对一个focus事件执行了 .triggerHandler() ，浏览器默认动作将不会被触发，只会触发你绑定的动作。</desc>
          <html>&lt;button id="old"&gt;.trigger("focus")&lt;/button&gt;
&lt;button id="new"&gt;.triggerHandler("focus")&lt;/button&gt;&lt;br/&gt;&lt;br/&gt;
&lt;input type="text" value="To Be Focused"/&gt;</html>
          <code>$("#old").click(function(){
  $("input").trigger("focus");
});
$("#new").click(function(){
  $("input").triggerHandler("focus");
});
$("input").focus(function(){
  $("&lt;span&gt;Focused!&lt;/span&gt;").appendTo("body").fadeOut(1000);
});</code>
        </example>
      </function>
      <function name="unbind" return="JPlus">
        <desc>bind()的反向操作，从每一个匹配的元素中删除绑定的事件。</desc>
        <longdesc>如果没有参数，则删除所有绑定的事件。

你可以将你用bind()注册的自定义事件取消绑定。

如果提供了事件类型作为参数，则只删除该类型的绑定事件。

如果把在绑定时传递的处理函数作为第二个参数，则只有这个特定的事件处理函数会被删除。</longdesc>
        <params name="type" type="String" optional="true">
          <desc>事件类型</desc>
        </params>
        <params name="fn" type="Function" optional="true">
          <desc>要从每个匹配元素的事件中反绑定的事件处理函数</desc>
        </params>
        <example>
          <desc>把所有段落的所有事件取消绑定</desc>
          <code>$("p").unbind()</code>
        </example>
        <example>
          <desc>将段落的click事件取消绑定</desc>
          <code>$("p").unbind( "click" )</code>
        </example>
        <example>
          <desc>删除特定函数的绑定，将函数作为第二个参数传入</desc>
          <code>var foo = function () {
  // 处理某个事件的代码
};

$("p").bind("click", foo); // ... 当点击段落的时候会触发 foo 

$("p").unbind("click", foo); // ... 再也不会被触发 foo</code>
        </example>
      </function>
    </subcat>
    <subcat value="事件委托">
      <function name="live" return="JPlus">
        <desc>JPlus 给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的也有效。</desc>
        <longdesc>这个方法是基本是的 .bind() 方法的一个变体。使用 .bind() 时，选择器匹配的元素会附加一个事件处理函数，而以后再添加的元素则不会有。为此需要再使用一次 .bind() 才行。比如说

&lt;pre&gt;&amp;lt;body&amp;gt;
  &amp;lt;div class=&quot;clickme&quot;&amp;gt;Click here&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;

可以给这个元素绑定一个简单的click事件：

&lt;pre&gt;$('.clickme').bind('click', function() {
  alert("Bound handler called.");
});
&lt;/pre&gt;

当点击了元素，就会弹出一个警告框。然后，想象一下这之后有另一个元素添加进来了。

&lt;pre&gt;$('body').append('&amp;lt;div class=&quot;clickme&quot;&amp;gt;Another target&amp;lt;/div&amp;gt;');&lt;/pre&gt;

尽管这个新的元素也能够匹配选择器 ".clickme" ，但是由于这个元素是在调用 .bind() 之后添加的，所以点击这个元素不会有任何效果。

.live() 就提供了对应这种情况的方法。如果我们是这样绑定click事件的：

&lt;pre&gt;$('.clickme').live('click', function() {
  alert("Live handler called."); 
});&lt;/pre&gt;

然后再添加一个新元素：

&lt;pre&gt;$('body').append('&amp;lt;div class=&quot;clickme&quot;&amp;gt;Another target&amp;lt;/div&amp;gt;');&lt;/pre&gt;

然后再点击新增的元素，他依然能够触发事件处理函数。

'''事件委托'''

.live() 方法能对一个还没有添加进DOM的元素有效，是由于使用了事件委托：绑定在祖先元素上的事件处理函数可以对在后代上触发的事件作出回应。传递给 .live() 的事件处理函数不会绑定在元素上，而是把他作为一个特殊的事件处理函数，绑定在 DOM 树的根节点上。在我们的例子中，当点击新的元素后，会依次发生下列步骤：

  &lt;ol&gt;
    &lt;li&gt;生成一个click事件传递给 &amp;lt;div&amp;gt; 来处理 &lt;/li&gt;
    &lt;li&gt;由于没有事件处理函数直接绑定在 &amp;lt;div&amp;gt; 上，所以事件冒泡到DOM树上&lt;/li&gt;
    &lt;li&gt;事件不断冒泡一直到DOM树的根节点，默认情况下上面绑定了这个特殊的事件处理函数。&lt;/li&gt;
    &lt;li&gt;执行由 .live() 绑定的特殊的 click 事件处理函数。&lt;/li&gt;
    &lt;li&gt;这个事件处理函数首先检测事件对象的 target 来确定是不是需要继续。这个测试是通过检测 $(event.target).closest('.clickme') 能否找到匹配的元素来实现的。&lt;/li&gt;
    &lt;li&gt;如果找到了匹配的元素，那么调用原始的事件处理函数。&lt;/li&gt;
  &lt;/ol&gt;

由于只有在事件发生时才会在上面的第五步里做测试，因此在任何时候添加的元素都能够响应这个事件。

'''附加说明'''

.live() 虽然很有用，但由于其特殊的实现方式，所以不能简单的在任何情况下替换 .bind()。主要的不同有：

&lt;ul&gt;
	&lt;li&gt;在JPlus 1.4中，.live()方法支持自定义事件，也支持所有的 JavaScript 事件。在JPlus 1.4.1中，甚至也支持 focus 和 blue 事件了（映射到更合适，并且可以冒泡的focusin和focusout上）。另外，在JPlus 1.4.1中，也能支持hover（映射到&quot;mouseenter mouseleave&quot;）。然而在JPlus 1.3.x中，只支持支持的JavaScript事件和自定义事件：click, dblclick, keydown, keypress, keyup, mousedown, mousemove, mouseout, mouseover, 和 mouseup.&lt;/li&gt;
	&lt;li&gt;.live() 并不完全支持通过DOM遍历的方法找到的元素。取而代之的是，应当总是在一个选择器后面直接使用 .live() 方法，正如前面例子里提到的。&lt;/li&gt;
	&lt;li&gt;当一个事件处理函数用 .live() 绑定后，要停止执行其他的事件处理函数，那么这个函数必须返回 false。 仅仅调用 .stopPropagation() 无法实现这个目的。&lt;/li&gt;
&lt;/ul&gt;

参考 .bind() 方法可以获得更多关于事件绑定的信息。

在JPlus 1.4.1中，你可以一次绑定多个事件给 .live() ，跟 .bind() 提供的功能类似。

在JPlus 1.4 中，data参数可以用于把附加信息传递给事件处理函数。一个很好的用处是应付由闭包导致的问题。可以参考 .bind() 的讨论来获得更多信息。

</longdesc>
        <params name="type" type="String">
          <desc>事件类型</desc>
        </params>
        <params name="data" type="Object" optional="true">
          <desc>欲绑定的事件处理函数</desc>
        </params>
        <params name="fn" type="Function">
          <desc>欲绑定的事件处理函数</desc>
        </params>
        <example>
          <desc>点击生成的p依然据有同样的功能。</desc>
          <html>&lt;p&gt;Click me!&lt;/p&gt;</html>
          <code>$("p").live("click", function(){
    $(this).after("&lt;p&gt;Another paragraph!&lt;/p&gt;");
});</code>
        </example>
        <example>
          <desc>阻止默认事件行为和事件冒泡，返回 false </desc>
          <code>$("a").live("click", function() { return false; });</code>
        </example>
        <example>
          <desc>仅仅阻止默认事件行为</desc>
          <code>$("a").live("click", function(event){
  event.preventDefault();
});</code>
        </example>
      </function>
      <function name="die" return="JPlus">
        <desc>JPlus 1.3新增。此方法与live正好完全相反。</desc>
        <longdesc>如果不带参数，则所有绑定的live事件都会被移除。

你可以解除用live注册的自定义事件。

如果提供了type参数，那么会移除对应的live事件。

如果也指定了第二个参数function,则只移出指定的事件处理函数。</longdesc>
        <params name="type" type="String" optional="true">
          <desc>要解除绑定的live事件</desc>
        </params>
        <params name="fn" type="Function" optional="true">
          <desc>要解除绑定的特定处理函数</desc>
        </params>
        <example>
          <desc>给按钮解除click事件</desc>
          <code>function aClick() {
      $("div").show().fadeOut("slow");
  }
  $("#unbind").click(function () {
      $("#theone").die("click", aClick)
  });</code>
        </example>
      </function>
    </subcat>
    <subcat value="事件切换">
      <function name="hover" return="JPlus">
        <desc>一个模仿悬停事件（鼠标移动到一个对象上面及移出这个对象）的方法。这是一个自定义的方法，它为频繁使用的任务提供了一种“保持在其中”的状态。</desc>
        <longdesc>当鼠标移动到一个匹配的元素上面时，会触发指定的第一个函数。当鼠标移出这个元素时，会触发指定的第二个函数。而且，会伴随着对鼠标是否仍然处在特定元素中的检测（例如，处在div中的图像），如果是，则会继续保持“悬停”状态，而不触发移出事件（修正了使用mouseout事件的一个常见错误）。</longdesc>
        <params name="over" type="Function">
          <desc>鼠标移到元素上要触发的函数</desc>
        </params>
        <params name="out" type="Function">
          <desc>鼠标移出元素要触发的函数</desc>
        </params>
        <example>
          <desc>鼠标悬停的表格加上特定的类</desc>
          <code>$("td").hover(
  function () {
    $(this).addClass("hover");
  },
  function () {
    $(this).removeClass("hover");
  }
);</code>
        </example>
      </function>
      <function name="toggle" return="JPlus">
        <desc>每次点击后依次调用函数。</desc>
        <longdesc>如果点击了一个匹配的元素，则触发指定的第一个函数，当再次点击同一元素时，则触发指定的第二个函数，如果有更多函数，则再次触发，直到最后一个。随后的每次点击都重复对这几个函数的轮番调用。

可以使用unbind("click")来删除。</longdesc>
        <params name="fn" type="Function">
          <desc>第一数次点击时要执行的函数。</desc>
        </params>
        <params name="fn2" type="Function">
          <desc>第二数次点击时要执行的函数。</desc>
        </params>
        <params name="fn3, fn4, ..." type="Function" optional="true">
          <desc>更多次点击时要执行的函数。</desc>
        </params>
        <example>
          <desc>对表格的切换一个类</desc>
          <html>  &lt;ul&gt;
    &lt;li&gt;Go to the store&lt;/li&gt;
    &lt;li&gt;Pick up dinner&lt;/li&gt;
    &lt;li&gt;Debug crash&lt;/li&gt;
    &lt;li&gt;Take a jog&lt;/li&gt;
  &lt;/ul&gt;</html>
          <code>$("td").toggle(
  function () {
    $(this).addClass("selected");
  },
  function () {
    $(this).removeClass("selected");
  }
);</code>
        </example>
        <example>
          <desc>对列表的切换样式</desc>
          <html>  &lt;ul&gt;
    &lt;li&gt;Go to the store&lt;/li&gt;
    &lt;li&gt;Pick up dinner&lt;/li&gt;
    &lt;li&gt;Debug crash&lt;/li&gt;
    &lt;li&gt;Take a jog&lt;/li&gt;
  &lt;/ul&gt;</html>
          <code>    $("li").toggle(
      function () {
        $(this).css({"list-style-type":"disc", "color":"blue"});
      },
      function () {
        $(this).css({"list-style-type":"disc", "color":"red"});
      },
      function () {
        $(this).css({"list-style-type":", "color":"});
      }
    );</code>
        </example>
      </function>
    </subcat>
    <subcat value="事件">
      <function name="blur" return="JPlus">
        <desc>触发每一个匹配元素的blur事件。</desc>
        <longdesc>这个函数会调用执行绑定到blur事件的所有函数，包括浏览器的默认行为。可以通过返回false来防止触发浏览器的默认行为。blur事件会在元素失去焦点的时候触发，既可以是鼠标行为，也可以是按tab键离开的</longdesc>
        <example>
          <desc>触发所有段落的blur事件</desc>
          <code>$("p").blur();</code>
        </example>
      </function>
      <function name="blur" return="JPlus">
        <desc>在每一个匹配元素的blur事件中绑定一个处理函数。</desc>
        <longdesc>blur事件会在元素失去焦点的时候触发，既可以是鼠标行为，也可以是按tab键离开的</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的blur事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>任何段落失去焦点时弹出一个 "Hello World!"在每一个匹配元素的blur事件中绑定的处理函数。</desc>
          <code>$("p").blur( function () { alert("Hello World!"); } );</code>
        </example>
      </function>
      <function name="change" return="JPlus">
        <desc>触发每个匹配元素的change事件</desc>
        <longdesc>这个函数会调用执行绑定到change事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。change事件会在元素失去焦点的时候触发，也会当其值在获得焦点后改变时触发。</longdesc>
      </function>
      <function name="change" return="JPlus">
        <desc>在每一个匹配元素的change事件中绑定一个处理函数。</desc>
        <longdesc>change事件会在元素失去焦点的时候触发，也会当其值在获得焦点后改变时触发。</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的change事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>给所有的文本框增加输入验证</desc>
          <code>$("input[type='text']").change( function() {
  // 这里可以写些验证代码
});</code>
        </example>
      </function>
      <function name="click" return="JPlus">
        <desc>触发每一个匹配元素的click事件。</desc>
        <longdesc>这个函数会调用执行绑定到click事件的所有函数。</longdesc>
        <example>
          <desc>触发页面内所有段落的点击事件</desc>
          <code>$("p").click();</code>
        </example>
      </function>
      <function name="click" return="JPlus">
        <desc>在每一个匹配元素的click事件中绑定一个处理函数。</desc>
        <longdesc>点击事件会在你的指针设备的按钮在元素上单击时触发。单击的定义是在屏幕的同一点触发了mousedown和mouseup.几个事件触发的顺序是：mousedownmouseupclick</longdesc>
        <params name="fn" type="Function">
          <desc>绑定到click事件的函数</desc>
        </params>
        <example>
          <desc>将页面内所有段落点击后隐藏。</desc>
          <code>$("p").click( function () { $(this).hide(); });</code>
        </example>
      </function>
      <function name="dblclick" return="JPlus">
        <desc>触发每一个匹配元素的dblclick事件。</desc>
        <longdesc>这个函数会调用执行绑定到dblclick事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。dblclick事件会在元素的同一点双击时触发。</longdesc>
      </function>
      <function name="dblclick" return="JPlus">
        <desc>在每一个匹配元素的dblclick事件中绑定一个处理函数。</desc>
        <longdesc>的那个在某个元素上双击的时候就会触发dblclick事件</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的dblclick事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>给页面上每个段落的双击事件绑上 "Hello World!" 警告框</desc>
          <code>$("p").dblclick( function () { alert("Hello World!"); });</code>
        </example>
      </function>
      <function name="error" return="JPlus">
        <desc>触发每一个匹配元素的error事件。</desc>
        <longdesc>这个函数会调用所有绑定到error事件上的函数，包括在对应元素上的浏览器默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。error事件通常可以在元素由于点击或者tab导航失去焦点时触发。</longdesc>
      </function>
      <function name="error" return="JPlus">
        <desc>在每一个匹配元素的error事件中绑定一个处理函数。</desc>
        <longdesc>对于error事件，没有一个公众的标准。在大多数浏览器中，当页面的JavaScript发生错误时，window对象会触发error事件;当图像的src属性无效时，比如文件不存在或者图像数据错误时，也会触发图像对象的error事件。

如果异常是由window对象抛出，事件处理函数将会被传入三个参数：

1. 描述事件的信息 ("varName is not defined", "missing operator in expression", 等等.),

2. 包含错误的文档的完整URL

3. 异常发生的行数 如果事件处理函数返回true，则表示事件已经被处理，浏览器将认为没有异常。

更多相关信息: 

&lt;a href="http://msdn2.microsoft.com/en-us/library/ms536930.aspx"&gt;msdn - onerror Event&lt;/a&gt;

&lt;a href="http://developer.mozilla.org/en/docs/DOM:window.onerror"&gt;Gecko DOM Reference - onerror Event&lt;/a&gt;

&lt;a href="http://developer.mozilla.org/en/docs/DOM:event"&gt;Gecko DOM Reference - Event object&lt;/a&gt;

&lt;a href="http://en.wikipedia.org/wiki/DOM_Events"&gt;Wikipedia: DOM Events&lt;/a&gt;</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的error事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>在服务器端记录JavaScript错误日志:</desc>
          <code>$(window).error(function(msg, url, line){
  JPlus.post("js_error_log.php", { msg: msg, url: url, line: line });
});</code>
        </example>
        <example>
          <desc>隐藏JavaScript错误:</desc>
          <code>$(window).error(function(){
  return true;
});</code>
        </example>
        <example>
          <desc>给你IE的用户隐藏无效的图像:</desc>
          <code>$("img").error(function(){
  $(this).hide();
});</code>
        </example>
      </function>
      <function name="focus" return="JPlus">
        <desc>触发每一个匹配元素的focus事件。</desc>
        <longdesc>这将触发所有绑定的focus函数，注意，某些对象不支持focus方法。</longdesc>
        <example>
          <desc>当页面加载后将 id 为 'login' 的元素设置焦点:</desc>
          <code>$(document).ready(function(){
  $("#login").focus();
});</code>
        </example>
      </function>
      <function name="focus" return="JPlus">
        <desc>在每一个匹配元素的focus事件中绑定一个处理函数。</desc>
        <longdesc>focus事件可以通过鼠标点击或者键盘上的TAB导航触发</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的focus事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>使人无法使用文本框:</desc>
          <code>$("input[type=text]").focus(function(){
  this.blur();
});</code>
        </example>
      </function>
      <function name="focusin" return="JPlus">
        <desc>在每一个匹配元素的focusin事件中绑定一个处理函数。</desc>
        <longdesc>当一个元素，或者其内部任何一个元素获得焦点的时候会触发这个事件。这跟focus事件区别在于，他可以在父元素上检测子元素获取焦点的情况。</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的focusin事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>获得焦点后会触发动画:</desc>
		  <html>&lt;p&gt;&lt;input type=&quot;text&quot; /&gt; &lt;span&gt;focusout fire&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;password&quot; /&gt; &lt;span&gt;focusout fire&lt;/span&gt;&lt;/p&gt;</html>
          <code>$("p").focusin(function() {
  $(this).find("span").css('display','inline').fadeOut(1000);
});</code>
        </example>
      </function>
      <function name="focusout" return="JPlus">
        <desc>在每一个匹配元素的focusout事件中绑定一个处理函数。</desc>
        <longdesc>当一个元素，或者其内部任何一个元素失去焦点的时候会触发这个事件。这跟blur事件区别在于，他可以在父元素上检测子元素失去焦点的情况。</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的focusout事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>失去焦点后会触发动画:</desc>
		  <html>&lt;p&gt;&lt;input type=&quot;text&quot; /&gt; &lt;span&gt;focusout fire&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;password&quot; /&gt; &lt;span&gt;focusout fire&lt;/span&gt;&lt;/p&gt;</html>
          <code>$("p").focusout(function() {
  $(this).find("span").css('display','inline').fadeOut(1000);
});</code>
        </example>
      </function>
      <function name="keydown" return="JPlus">
        <desc>触发每一个匹配元素的keydown事件</desc>
        <longdesc>这个函数会调用执行绑定到keydown事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。keydown事件会在键盘按下时触发。</longdesc>
      </function>
      <function name="keydown" return="JPlus">
        <desc>在每一个匹配元素的keydown事件中绑定一个处理函数。</desc>
        <longdesc>keydown事件会在键盘按下时触发。</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的keydown事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>在页面内对键盘按键做出回应，可以使用如下代码:</desc>
          <code>$(window).keydown(function(event){
  switch(event.keyCode) {
    // ...
    // 不同的按键可以做不同的事情
    // 不同的浏览器的keycode不同
    // 更多详细信息:     http://unixpapa.com/js/key.html
    // ...
  }
});</code>
        </example>
      </function>
      <function name="keypress" return="JPlus">
        <desc>触发每一个匹配元素的keypress事件</desc>
        <longdesc>T这个函数会调用执行绑定到keydown事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。keydown事件会在键盘按下时触发</longdesc>
      </function>
      <function name="keypress" return="JPlus">
        <desc>在每一个匹配元素的keypress事件中绑定一个处理函数。</desc>
        <longdesc>keypress事件会在敲击按键时触发。 敲击按键的定义为按下并抬起同一个按键。这几个事件发生的顺序是:keydown

keypress

keyup</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的keypress事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="keyup" return="JPlus">
        <desc>触发每一个匹配元素的keyup事件</desc>
        <longdesc>这个函数会调用执行绑定到keyup事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。keyup事件会在按键释放时触发。</longdesc>
      </function>
      <function name="keyup" return="JPlus">
        <desc>在每一个匹配元素的keyup事件中绑定一个处理函数。</desc>
        <longdesc>keyup 事件会在键盘按下时触发。</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的keyup事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="load" return="JPlus">
        <desc>在每一个匹配元素的load事件中绑定一个处理函数。</desc>
        <longdesc>如果绑定给window对象，则会在所有内容加载后触发，包括窗口，框架，对象和图像。如果绑定在元素上，则当元素的内容加载完毕后触发。

'''注意:'''只有当在这个元素完全加载完之前绑定load的处理函数,才会在他加载完后触发。如果之后再绑定就永远不会触发了。所以'''不要'''在$(document).ready()里绑定load事件，因为JPlus会在所有DOM加载完成后再绑定load事件。</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的load事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="mousedown" return="JPlus">
        <desc>在每一个匹配元素的mousedown事件中绑定一个处理函数。</desc>
        <longdesc>mousedown事件在鼠标在元素上点击后会触发</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的mousedown事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="mousemove" return="JPlus">
        <desc>在每一个匹配元素的mousemove事件中绑定一个处理函数。</desc>
        <longdesc>mousemove 事件通过鼠标在元素上移动来触发。事件处理函数会被传递一个变量——事件对象，其.clientX 和 .clientY 属性代表鼠标的坐标</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的mousemove事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="mouseout" return="JPlus">
        <desc>在每一个匹配元素的mouseout事件中绑定一个处理函数。</desc>
        <longdesc>mouseout事件在鼠标从元素上离开后会触发</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的mouseout事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="mouseover" return="JPlus">
        <desc>在每一个匹配元素的mouseover事件中绑定一个处理函数。</desc>
        <longdesc>mouseover事件会在鼠标移入对象时触发</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的mouseover事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="mouseup" return="JPlus">
        <desc>在每一个匹配元素的mouseup事件中绑定一个处理函数。</desc>
        <longdesc>mouseup事件会在鼠标点击对象释放时</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的mouseup事件中绑定的处理函数。</desc>
        </params>
      </function>
      <function name="resize" return="JPlus">
        <desc>在每一个匹配元素的resize事件中绑定一个处理函数。</desc>
        <longdesc>当文档窗口改变大小时触发</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的resize事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>让人每次改变页面窗口的大小时很郁闷的方法:</desc>
          <code>$(window).resize(function(){
  alert("Stop it!");
});</code>
        </example>
      </function>
      <function name="scroll" return="JPlus">
        <desc>在每一个匹配元素的scroll事件中绑定一个处理函数。</desc>
        <longdesc>当滚动条发生变化时触发</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的resize事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>当页面滚动条变化时，执行的函数:</desc>
          <code>$(window).scroll( function() { /* ...do something... */ } );</code>
        </example>
      </function>
      <function name="select" return="JPlus">
        <desc>触发每一个匹配元素的select事件</desc>
        <longdesc>这个函数会调用执行绑定到select事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。</longdesc>
        <example>
          <desc>触发所有input元素的select事件:</desc>
          <code>$("input").select();</code>
        </example>
      </function>
      <function name="select" return="JPlus">
        <desc>在每一个匹配元素的select事件中绑定一个处理函数。</desc>
        <longdesc>当用户在文本框(包括input和textarea)中选中某段文本时会触发select事件。</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的select事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>当文本框中文本被选中时执行的函数:</desc>
          <code>$(":text").select( function () { /* ...do something... */ } );</code>
        </example>
      </function>
      <function name="submit" return="JPlus">
        <desc>触发每一个匹配元素的submit事件。</desc>
        <longdesc>这个函数会调用执行绑定到submit事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。</longdesc>
        <example>
          <desc>提交本页的第一个表单:</desc>
          <code>$("form:first").submit();</code>
        </example>
      </function>
      <function name="submit" return="JPlus">
        <desc>在每一个匹配元素的submit事件中绑定一个处理函数。</desc>
        <longdesc>submit事件将会在表单提交时触发</longdesc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的submit事件中绑定的处理函数</desc>
        </params>
        <example>
          <desc>如果你要阻止表单提交:</desc>
          <code>$("form").submit( function () {
  return false;
} );</code>
        </example>
      </function>
      <function name="unload" return="JPlus">
        <desc>在每一个匹配元素的unload事件中绑定一个处理函数。</desc>
        <params name="fn" type="Function">
          <desc>在每一个匹配元素的unload事件中绑定的处理函数。</desc>
        </params>
        <example>
          <desc>页面卸载的时候弹出一个警告框:</desc>
          <code>$(window).unload( function () { alert("Bye now!"); } );</code>
        </example>
      </function>
    </subcat>
  </cat>
  <cat value="效果">
    <subcat value="基本">
      <function name="show" return="JPlus">
        <desc>显示隐藏的匹配元素。</desc>
        <longdesc>这个就是 'show( speed, [callback] )' 无动画的版本。如果选择的元素是可见的，这个方法将不会改变任何东西。无论这个元素是通过hide()方法隐藏的还是在CSS里设置了display:none;，这个方法都将有效。</longdesc>
        <example>
          <desc>显示所有段落</desc>
          <html>&lt;p style="display: none"&gt;Hello&lt;/p&gt;</html>
          <code>$("p").show()</code>
        </example>
      </function>
      <function name="show" return="JPlus">
        <desc>以优雅的动画显示所有匹配的元素，并在显示完成后可选地触发一个回调函数。</desc>
        <longdesc>可以根据指定的速度动态地改变每个匹配元素的高度、宽度和不透明度。在JPlus 1.3中，padding和margin也会有动画，效果更流畅。</longdesc>
        <params name="speed" type="String,Number">
          <desc>三种预定速度之一的字符串("slow", "normal", or "fast")或表示动画时长的毫秒数值(如：1000)</desc>
        </params>
        <params name="callback" type="Function" optional="true">
          <desc>在动画完成时执行的函数，每个元素执行一次。</desc>
        </params>
        <example>
          <desc>用缓慢的动画将隐藏的段落显示出来，历时600毫秒。</desc>
          <html>&lt;p style="display: none"&gt;Hello&lt;/p&gt;</html>
          <code>$("p").show("slow");</code>
        </example>
        <example>
          <desc>用迅速的动画将隐藏的段落显示出来，历时200毫秒。并在之后执行反馈！</desc>
          <html>&lt;p style="display: none"&gt;Hello&lt;/p&gt;</html>
          <code>$("p").show("fast",function(){
   $(this).text("Animation Done!");
 });</code>
        </example>
        <example>
          <desc>将隐藏的段落用将近4秒的时间显示出来。。。并在之后执行一个反馈。。。</desc>
          <html>&lt;p style="display: none"&gt;Hello&lt;/p&gt;</html>
          <code>$("p").show(4000,function(){
   $(this).text("Animation Done...");
 });</code>
        </example>
      </function>
      <function name="hide" return="JPlus">
        <desc>隐藏显示的元素</desc>
        <longdesc>这个就是 'hide( speed, [callback] )' 的无动画版。如果选择的元素是隐藏的，这个方法将不会改变任何东西。</longdesc>
        <example>
          <desc>隐藏所有段落</desc>
          <code>$("p").hide()</code>
        </example>
      </function>
      <function name="hide" return="JPlus">
        <desc>以优雅的动画隐藏所有匹配的元素，并在显示完成后可选地触发一个回调函数。</desc>
        <longdesc>可以根据指定的速度动态地改变每个匹配元素的高度、宽度和不透明度。在JPlus 1.3中，padding和margin也会有动画，效果更流畅。</longdesc>
        <params name="speed" type="String,Number">
          <desc>三种预定速度之一的字符串("slow", "normal", or "fast")或表示动画时长的毫秒数值(如：1000)</desc>
        </params>
        <params name="callback" type="Function" optional="true">
          <desc>在动画完成时执行的函数，每个元素执行一次。</desc>
        </params>
        <example>
          <desc>用600毫秒的时间将段落缓慢的隐藏</desc>
          <code>$("p").hide("slow");</code>
        </example>
        <example>
          <desc>用200毫秒将段落迅速隐藏，之后弹出一个对话框。</desc>
          <code>$("p").hide("fast",function(){
   alert("Animation Done.");
 });</code>
        </example>
      </function>
      <function name="toggle" return="JPlus">
        <desc>切换元素的可见状态。</desc>
        <longdesc>如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。</longdesc>
        <example>
          <desc>切换所有段落的可见状态。</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p style="display: none"&gt;Hello Again&lt;/p&gt;</html>
          <code>$("p").toggle()</code>
          <result>&lt;p tyle="display: none"&gt;Hello&lt;/p&gt;&lt;p style="display: block"&gt;Hello Again&lt;/p&gt;</result>
        </example>
      </function>
      <function name="toggle" return="JPlus">
        <desc>根据switch参数切换元素的可见状态（ture为可见，false为隐藏）。</desc>
        <longdesc>如果switch设为true，则调用show()方法来显示匹配的元素，如果switch设为false则调用hide()来隐藏元素。</longdesc>
        <params name="switch" type="Boolean">
          <desc>用于确定显示/隐藏的开关</desc>
        </params>
        <example>
          <desc>切换所有段落的可见状态。</desc>
          <html>&lt;p&gt;Hello&lt;/p&gt;&lt;p style="display: none"&gt;Hello Again&lt;/p&gt;</html>
          <code>  var flip = 0;
  $("button").click(function () {
      $("p").toggle( flip++ % 2 == 0 );
  });</code>
          <result>&lt;p tyle="display: none"&gt;Hello&lt;/p&gt;&lt;p style="display: block"&gt;Hello Again&lt;/p&gt;</result>
        </example>
      </function>
      <function name="toggle" return="JPlus">
        <desc>以优雅的动画切换所有匹配的元素，并在显示完成后可选地触发一个回调函数。</desc>
        <longdesc>可以根据指定的速度动态地改变每个匹配元素的高度、宽度和不透明度。在JPlus 1.3中，padding和margin也会有动画，效果更流畅。</longdesc>
        <params name="speed" type="String,Number">
          <desc>三种预定速度之一的字符串("slow", "normal", or "fast")或表示动画时长的毫秒数值(如：1000)</desc>
        </params>
        <params name="callback" type="Function" optional="true">
          <desc>在动画完成时执行的函数，每个元素执行一次。</desc>
        </params>
        <example>
          <desc>用600毫秒的时间将段落缓慢的切换显示状态</desc>
          <code>$("p").toggle("slow");</code>
        </example>
        <example>
          <desc>用200毫秒将段落迅速切换显示状态，之后弹出一个对话框。</desc>
          <code>$("p").toggle("fast",function(){
   alert("Animation Done.");
 });</code>
        </example>
      </function>
    </subcat>
    <subcat value="滑动">
      <function name="slideDown" return="JPlus">
        <desc>通过高度变化（向下增大）来动态地显示所有匹配的元素，在显示完成后可选地触发一个回调函数。</desc>
        <longdesc>这个动画效果只调整元素的高度，可以使匹配的元素以“滑动”的方式显示出来。在JPlus 1.3中，上下的padding和margin也会有动画，效果更流畅。</longdesc>
        <params name="speed" type="String,Number">
          <desc>三种预定速度之一的字符串("slow", "normal", or "fast")或表示动画时长的毫秒数值(如：1000)</desc>
        </params>
        <params name="callback" type="FunctionFunction" optional="true">
          <desc>在动画完成时执行的函数</desc>
        </params>
        <example>
          <desc>用600毫秒缓慢的将段落滑下</desc>
          <code>$("p").slideDown("slow");</code>
        </example>
        <example>
          <desc>用200毫秒快速将段落滑下，之后弹出一个对话框</desc>
          <code>$("p").slideDown("fast",function(){
   alert("Animation Done.");
 });</code>
        </example>
      </function>
      <function name="slideUp" return="JPlus">
        <desc>通过高度变化（向上减小）来动态地隐藏所有匹配的元素，在隐藏完成后可选地触发一个回调函数。</desc>
        <longdesc>这个动画效果只调整元素的高度，可以使匹配的元素以“滑动”的方式隐藏起来。在JPlus 1.3中，上下的padding和margin也会有动画，效果更流畅。</longdesc>
        <params name="speed" type="String,Number">
          <desc>三种预定速度之一的字符串("slow", "normal", or "fast")或表示动画时长的毫秒数值(如：1000)</desc>
        </params>
        <params name="callback" type="Function" optional="true">
          <desc>在动画完成时执行的函数</desc>
        </params>
        <example>
          <desc>用600毫秒缓慢的将段落滑上</desc>
          <code>$("p").slideUp("slow");</code>
        </example>
        <example>
          <desc>用200毫秒快速将段落滑上，之后弹出一个对话框</desc>
          <code>$("p").slideUp("fast",function(){
   alert("Animation Done.");
 });</code>
        </example>
      </function>
      <function name="slideToggle" return="JPlus">
        <desc>通过高度变化来切换所有匹配元素的可见性，并在切换完成后可选地触发一个回调函数。</desc>
        <longdesc>这个动画效果只调整元素的高度，可以使匹配的元素以“滑动”的方式隐藏或显示。在JPlus 1.3中，上下的padding和margin也会有动画，效果更流畅。</longdesc>
        <params name="speed" type="String,Number">
          <desc>三种预定速度之一的字符串("slow", "normal", or "fast")或表示动画时长的毫秒数值(如：1000)</desc>
        </params>
        <params name="callback" type="Function" optional="true">
          <desc>在动画完成时执行的函数</desc>
        </params>
        <example>
          <desc>用600毫秒缓慢的将段落滑上或滑下</desc>
          <code>$("p").slideToggle("slow");</code>
        </example>
        <example>
          <desc>用200毫秒快速将段落滑上或滑下，之后弹出一个对话框</desc>
          <code>$("p").slideToggle("fast",function(){
   alert("Animation Done.");
 });</code>
        </example>
      </function>
    </subcat>
    <subcat value="淡入淡出">
      <function name="fadeIn" return="JPlus">
        <desc>通过不透明度的变化来实现所有匹配元素的淡入效果，并在动画完成后可选地触发一个回调函数。</desc>
        <longdesc>这个动画只调整元素的不透明度，也就是说所有匹配的元素的高度和宽度不会发生变化。</longdesc>
        <params name="speed" type="String,Number">
          <desc>三种预定速度之一的字符串("slow", "normal", or "fast")或表示动画时长的毫秒数值(如：1000)</desc>
        </params>
        <params name="callback" type="Function" optional="true">
          <desc>(Optional) 在动画完成时执行的函数</desc>
        </params>
        <example>
          <desc>用600毫秒缓慢的将段落淡入</desc>
          <code>$("p").fadeIn("slow");</code>
        </example>
        <example>
          <desc>用200毫秒快速将段落淡入，之后弹出一个对话框</desc>
          <code>$("p").fadeIn("fast",function(){
   alert("Animation Done.");
 });</code>
        </example>
      </function>
      <function name="fadeOut" return="JPlus">
        <desc>通过不透明度的变化来实现所有匹配元素的淡出效果，并在动画完成后可选地触发一个回调函数。</desc>
        <longdesc>这个动画只调整元素的不透明度，也就是说所有匹配的元素的高度和宽度不会发生变化。</longdesc>
        <params name="speed" type="String,Number">
          <desc>三种预定速度之一的字符串("slow", "normal", or "fast")或表示动画时长的毫秒数值(如：1000)</desc>
        </params>
        <params name="callback" type="Function" optional="true">
          <desc>在动画完成时执行的函数</desc>
        </params>
        <example>
          <desc>用600毫秒缓慢的将段落淡出</desc>
          <code>$("p").fadeOut("slow");</code>
        </example>
        <example>
          <desc>用200毫秒快速将段落淡出，之后弹出一个对话框</desc>
          <code>$("p").fadeOut("fast",function(){
   alert("Animation Done.");
 });</code>
        </example>
      </function>
      <function name="fadeTo" return="JPlus">
        <desc>把所有匹配元素的不透明度以渐进方式调整到指定的不透明度，并在动画完成后可选地触发一个回调函数。</desc>
        <longdesc>这个动画只调整元素的不透明度，也就是说所有匹配的元素的高度和宽度不会发生变化。</longdesc>
        <params name="speed" type="String,Number">
          <desc>三种预定速度之一的字符串("slow", "normal", or "fast")或表示动画时长的毫秒数值(如：1000)</desc>
        </params>
        <params name="opacity" type="Number">
          <desc>要调整到的不透明度值(0到1之间的数字).</desc>
        </params>
        <params name="callback" type="Function" optional="true">
          <desc>在动画完成时执行的函数</desc>
        </params>
        <example>
          <desc>用600毫秒缓慢的将段落的透明度调整到0.66，大约2/3的可见度</desc>
          <code>$("p").fadeTo("slow", 0.66);$("p").fadeTo("slow", 0.66);</code>
        </example>
        <example>
          <desc>用200毫秒快速将段落的透明度调整到0.25，大约1/4的可见度，之后弹出一个对话框</desc>
          <code>$("p").fadeTo("fast", 0.25, function(){
   alert("Animation Done.");
 });</code>
        </example>
      </function>
    </subcat>
    <subcat value="自定义">
      <function name="animate" return="JPlus">
        <desc>用于创建自定义动画的函数。</desc>
        <longdesc>这个函数的关键在于指定动画形式及结果样式属性对象。这个对象中每个属性都表示一个可以变化的样式属性（如“height”、“top”或“opacity”）。注意：所有指定的属性必须用骆驼形式，比如用marginLeft代替margin-left. 

而每个属性的值表示这个样式属性到多少时动画结束。如果是一个数值，样式属性就会从当前的值渐变到指定的值。如果使用的是“hide”、“show”或“toggle”这样的字符串值，则会为该属性调用默认的动画形式。

在 JPlus 1.2 中，你可以使用 em 和 % 单位。另外，在 JPlus 1.2 中，你可以通过在属性值前面指定 "&lt;em&gt;+=&lt;/em&gt;" 或 "&lt;em&gt;-=&lt;/em&gt;" 来让元素做相对运动。

JPlus 1.3中，如果duration设为0则直接完成动画。而在以前版本中则会执行默认动画。</longdesc>
        <params name="params" type="Options">
          <desc>一组包含作为动画属性和终值的样式属性和及其值的集合</desc>
        </params>
        <params name="duration" type="String,Number" optional="true">
          <desc>三种预定速度之一的字符串("slow", "normal", or "fast")或表示动画时长的毫秒数值(如：1000)</desc>
        </params>
        <params name="easing" type="String" optional="true">
          <desc>要使用的擦除效果的名称(需要插件支持).默认JPlus提供"linear" 和 "swing".</desc>
        </params>
        <params name="callback" type="Function" optional="true">
          <desc>在动画完成时执行的函数</desc>
        </params>
        <example>
          <desc>点击按钮后div元素的几个不同属性一同变化</desc>
          <html>&lt;button id="go"&gt; Run&lt;/button&gt;
&lt;div id="block"&gt;Hello!&lt;/div&gt;</html>
          <code>// 在一个动画中同时应用三种类型的效果
$("#go").click(function(){
  $("#block").animate({ 
    width: "90%",
    height: "100%", 
    fontSize: "10em", 
    borderWidth: 10
  }, 1000 );
});</code>
        </example>
        <example>
          <desc>让指定元素左右移动</desc>
          <html>&lt;button id="left"&gt;«&lt;/button&gt; &lt;button id="right"&gt;»&lt;/button&gt;
&lt;div class="block"&gt;&lt;/div&gt;</html>
          <code>$("#right").click(function(){
  $(".block").animate({left: '+50px'}, "slow");
});

$("#left").click(function(){
  $(".block").animate({left: '-50px'}, "slow");
});</code>
        </example>
        <example>
          <desc>在600毫秒内切换段落的高度和透明度</desc>
          <code>$("p").animate({
   height: 'toggle', opacity: 'toggle'
 }, "slow");</code>
        </example>
        <example>
          <desc>用500毫秒将段落移到left为50的地方并且完全清晰显示出来（透明度为1）</desc>
          <code>$("p").animate({
   left: 50, opacity: 'show'
 }, 500);</code>
        </example>
        <example>
          <desc>一个使用“easein”函数提供不同动画样式的例子。只有使用了插件来提供这个“easein”函数，这个参数才起作用。</desc>
          <code>$("p").animate({
   opacity: 'show'
 }, "slow", "easein");</code>
        </example>
      </function>
      <function name="animate" return="JPlus">
        <desc>用于创建自定义动画的函数。</desc>
        <longdesc>这个函数的关键在于指定动画形式及结果样式属性对象。这个对象中每个属性都表示一个可以变化的样式属性（如“height”、“top”或“opacity”）。注意：所有指定的属性必须用骆驼形式，比如用marginLeft代替margin-left. 

而每个属性的值表示这个样式属性到多少时动画结束。如果是一个数值，样式属性就会从当前的值渐变到指定的值。如果使用的是“hide”、“show”或“toggle”这样的字符串值，则会为该属性调用默认的动画形式。

在 JPlus 1.2 中，你可以使用 em 和 % 单位。另外，在 JPlus 1.2 中，你可以通过在属性值前面指定 "&lt;em&gt;+=&lt;/em&gt;" 或 "&lt;em&gt;-=&lt;/em&gt;" 来让元素做相对运动。</longdesc>
        <params name="params" type="Options">
          <desc>一组包含作为动画属性和终值的样式属性和及其值的集合</desc>
        </params>
        <params name="options" type="Options">
          <desc>一组包含动画选项的值的集合。</desc>
        </params>
        <option name="duration" type="String,Number">
          <desc>(默认值: "normal") 三种预定速度之一的字符串("slow", "normal", or "fast")或表示动画时长的毫秒数值(如：1000)</desc>
        </option>
        <option name="easing" type="String">
          <desc>(默认值: "swing") 要使用的擦除效果的名称(需要插件支持).默认JPlus提供"linear" 和 "swing".</desc>
        </option>
        <option name="complete" type="Function">
          <desc>在动画完成时执行的函数</desc>
        </option>
        <option name="step" type="Callback">
          <desc></desc>
        </option>
        <option name="queue" type="Boolean">
          <desc>(默认值: true) 设定为false将使此动画不进入动画队列 (JPlus 1.2中新增)</desc>
        </option>
        <example>
          <desc>第一个按钮按了之后展示了不在队列中的动画。在div扩展到90%的同时也在增加字体，一旦字体改变完毕后，边框的动画才开始。</desc>
          <html>&lt;button id="go1"&gt;» Animate Block1&lt;/button&gt;
&lt;button id="go2"&gt;» Animate Block2&lt;/button&gt;
&lt;div id="block1"&gt;Block1&lt;/div&gt;&lt;div id="block2"&gt;Block2&lt;/div&gt;</html>
          <code>$("#go1").click(function(){
  $("#block1").animate( { width: "90%"}, { queue: false, duration: 5000 } )
     .animate( { fontSize: '10em' } , 1000 )
     .animate( { borderWidth: 5 }, 1000);
});

$("#go2").click(function(){
  $("#block2").animate( { width: "90%"}, 1000 )
     .animate( { fontSize: '10em' } , 1000 )
     .animate( { borderWidth: 5 }, 1000);
});</code>
        </example>
        <example>
          <desc>第二个按钮按了之后就是一个传统的链式动画，即等前一个动画完成后，后一个动画才会开始.</desc>
          <html>&lt;button id="go1"&gt;» Animate Block1&lt;/button&gt;
&lt;button id="go2"&gt;» Animate Block2&lt;/button&gt;
&lt;div id="block1"&gt;Block1&lt;/div&gt;&lt;div id="block2"&gt;Block2&lt;/div&gt;</html>
          <code>$("#go1").click(function(){
  $("#block1").animate( { width: "90%"}, { queue: false, duration: 5000 } )
     .animate( { fontSize: '10em' } , 1000 )
     .animate( { borderWidth: 5 }, 1000);
});

$("#go2").click(function(){
  $("#block2").animate( { width: "90%"}, 1000 )
     .animate( { fontSize: '10em' } , 1000 )
     .animate( { borderWidth: 5 }, 1000);
});</code>
        </example>
        <example>
          <desc>用600毫秒切换段落的高度和透明度</desc>
          <code>$("p").animate({
   height: 'toggle', opacity: 'toggle'
 }, { duration: "slow" });</code>
        </example>
        <example>
          <desc>用500毫秒将段落移到left为50的地方并且完全清晰显示出来（透明度为1）</desc>
          <code>$("p").animate({
   left: 50, opacity: 'show'
 }, { duration: 500 });</code>
        </example>
        <example>
          <desc>一个使用“easein”函数提供不同动画样式的例子。只有使用了插件来提供这个“easein”函数，这个参数才起作用。</desc>
          <code>$("p").animate({
   opacity: 'show'
 }, { duration: "slow", easing: "easein" });</code>
        </example>
      </function>
      <function name="stop" return="JPlus">
        <desc>停止所有在指定元素上正在运行的动画。</desc>
        <longdesc>如果队列中有等待执行的动画(并且clearQueue没有设为true)，他们将被马上执行</longdesc>
        <params name="clearQueue" type="Boolean" optional="true">
          <desc>如果设置成true，则清空队列。可以立即结束动画。</desc>
        </params>
        <params name="gotoEnd" type="Boolean" optional="true">
          <desc>让当前正在执行的动画立即完成，并且重设show和hide的原始样式，调用回调函数等。</desc>
        </params>
        <example>
          <desc>点击Go之后开始动画,点Stop之后会在当前位置停下来</desc>
          <html>&lt;button id="go"&gt;Go&lt;/button&gt; &lt;button id="stop"&gt;STOP!&lt;/button&gt;
&lt;div class="block"&gt;&lt;/div&gt;&lt;button id="go"&gt;Go&lt;/button&gt; &lt;button id="stop"&gt;STOP!&lt;/button&gt;
&lt;div class="block"&gt;&lt;/div&gt;</html>
          <code>// 开始动画
$("#go").click(function(){
  $(".block").animate({left: '+200px'}, 5000);
});

// 当点击按钮后停止动画
$("#stop").click(function(){
  $(".block").stop();
});</code>
        </example>
      </function>
      <function name="delay" return="JPlus">
        <desc>设置一个延时来推迟执行队列中之后的项目。</desc>
        <longdesc>JPlus 1.4新增。用于将队列中的函数延时执行。他既可以推迟动画队列的执行，也可以用于自定义队列。</longdesc>
        <params name="duration" type="Integer">
          <desc>延时时间，单位：毫秒</desc>
        </params>
        <params name="queueName" type="String" optional="true">
          <desc>队列名词，默认是Fx，动画队列。</desc>
        </params>
        <example>
          <desc>在.slideUp() 和 .fadeIn()之间延时800毫秒。</desc>
          <html>&lt;div id=&quot;foo /&quot;&gt;</html>
          <code>$('#foo').slideUp(300).delay(800).fadeIn(400);</code>
        </example>
      </function>
	</subcat>
    <subcat value="设置">
      <property name="JPlus.fx.off" return="Boolean">
        <desc>关闭页面上所有的动画。</desc>
        <longdesc>把这个属性设置为true可以立即关闭所有动画(所有效果会立即执行完毕)。有些情况下可能需要这样，比如：

* 你在配置比较低的电脑上使用JPlus。

* 你的一些用户由于动画效果而遇到了 &lt;a href="http://www.jdeegan.phlegethon.org/turn_off_animation.html"&gt;可访问性问题&lt;/a&gt;

当把这个属性设成false之后，可以重新开启所有动画。</longdesc>
        <example>
          <desc>执行一个禁用的动画</desc>
          <code>  JPlus.fx.off = true;
  $("input").click(function(){
      $("div").toggle("slow");
  });</code>
        </example>
      </property>
    </subcat>
  </cat>
  <cat value="Ajax">
    <subcat value="Ajax 请求">
      <function name="JPlus.ajax" return="XMLHttpRequest">
        <desc>通过 HTTP 请求加载远程数据。</desc>
        <longdesc>JPlus 底层 AJAX 实现。简单易用的高层实现见 $.get, $.post 等。$.ajax() 返回其创建的 XMLHttpRequest 对象。大多数情况下你无需直接操作该函数，除非你需要操作不常用的选项，以获得更多的灵活性。

最简单的情况下，$.ajax()可以不带任何参数直接使用。

'''注意'''，所有的选项都可以通过$.ajaxSetup()函数来全局设置。

'''回调函数'''

如果要处理$.ajax()得到的数据，则需要使用回调函数。beforeSend、error、dataFilter、success、complete。

&lt;ul&gt;
    &lt;li&gt;beforeSend 在发送请求之前调用，并且传入一个XMLHttpRequest作为参数。&lt;/li&gt;
    &lt;li&gt;error 在请求出错时调用。传入XMLHttpRequest对象，描述错误类型的字符串以及一个异常对象（如果有的话）&lt;/li&gt;
    &lt;li&gt;dataFilter 在请求成功之后调用。传入返回的数据以及&quot;dataType&quot;参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数。&lt;/li&gt;
    &lt;li&gt;success 当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。&lt;/li&gt;
    &lt;li&gt;complete 当请求完成之后调用这个函数，无论成功或失败。传入XMLHttpRequest对象，以及一个包含成功或错误代码的字符串。&lt;/li&gt;
&lt;/ul&gt;

'''数据类型'''

$.ajax()函数依赖服务器提供的信息来处理返回的数据。如果服务器报告说返回的数据是XML，那么返回的结果就可以用普通的XML方法或者JPlus的选择器来遍历。如果见得到其他类型，比如HTML，则数据就以文本形式来对待。

通过dataType选项还可以指定其他不同数据处理方式。除了单纯的XML，还可以指定 html、json、jsonp、script或者text。

其中，text和xml类型返回的数据不会经过处理。数据仅仅简单的将XMLHttpRequest的responseText或responseHTML属性传递给success回调函数，

'''注意'''，我们必须确保网页服务器报告的MIME类型与我们选择的dataType所匹配。比如说，XML的话，服务器端就必须声明 text/xml 或者 application/xml 来获得一致的结果。

如果指定为html类型，任何内嵌的JavaScript都会在HTML作为一个字符串返回之前执行。类似的，指定script类型的话，也会先执行服务器端生成JavaScript，然后再把脚本作为一个文本数据返回。

如果指定为json类型，则会把获取到的数据作为一个JavaScript对象来解析，并且把构建好的对象作为结果返回。为了实现这个目的，他首先尝试使用JSON.parse()。如果浏览器不支持，则使用一个函数来构建。JSON数据是一种能很方便通过JavaScript解析的结构化数据。如果获取的数据文件存放在远程服务器上（域名不同，也就是跨域获取数据），则需要使用jsonp类型。使用这种类型的话，会创建一个查询字符串参数 callback=? ，这个参数会加在请求的URL后面。服务器端应当在JSON数据前加上回调函数名，以便完成一个有效的JSONP请求。如果要指定回调函数的参数名来取代默认的callback，可以通过设置$.ajax()的jsonp参数。

'''注意'''，JSONP是JSON格式的扩展。他要求一些服务器端的代码来检测并处理查询字符串参数。更多信息可以参阅 &lt;a href=&quot;http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/&quot;&gt;最初的文章&lt;/a&gt;。

如果指定了script或者jsonp类型，那么当从服务器接收到数据时，实际上是用了&amp;lt;script&amp;gt;标签而不是XMLHttpRequest对象。这种情况下，$.ajax()不再返回一个XMLHttpRequest对象，并且也不会传递事件处理函数，比如beforeSend。

'''发送数据到服务器'''

默认情况下，Ajax请求使用GET方法。如果要使用POST方法，可以设定type参数值。这个选项也会影响data选项中的内容如何发送到服务器。

data选项既可以包含一个查询字符串，比如 key1=value1&amp;amp;key2=value2 ，也可以是一个映射，比如 {key1: 'value1', key2: 'value2'} 。如果使用了后者的形式，则数据再发送器会被转换成查询字符串。这个处理过程也可以通过设置processData选项为false来回避。如果我们希望发送一个XML对象给服务器时，这种处理可能并不合适。并且在这种情况下，我们也应当改变contentType选项的值，用其他合适的MIME类型来取代默认的  application/x-www-form-urlencoded 。

'''高级选项'''

global选项用于阻止响应注册的回调函数，比如.ajaxSend，或者ajaxError，以及类似的方法。这在有些时候很有用，比如发送的请求非常频繁且简短的时候，就可以在ajaxSend里禁用这个。更多关于这些方法的详细信息，请参阅下面的内容。

如果服务器需要HTTP认证，可以使用用户名和密码可以通过username和password选项来设置。

Ajax请求是限时的，所以错误警告被捕获并处理后，可以用来提升用户体验。请求超时这个参数通常就保留其默认值，要不就通过JPlus.ajaxSetup来全局设定，很少为特定的请求重新设置timeout选项。

默认情况下，请求总会被发出去，但浏览器有可能从他的缓存中调取数据。要禁止使用缓存的结果，可以设置cache参数为false。如果希望判断数据自从上次请求后没有更改过就报告出错的话，可以设置ifModified为true。

scriptCharset允许给&amp;lt;script&amp;gt;标签的请求设定一个特定的字符集，用于script或者jsonp类似的数据。当脚本和页面字符集不同时，这特别好用。

Ajax的第一个字母是asynchronous的开头字母，这意味着所有的操作都是并行的，完成的顺序没有前后关系。$.ajax()的async参数总是设置成true，这标志着在请求开始后，其他代码依然能够执行。强烈不建议把这个选项设置成false，这意味着所有的请求都不再是异步的了，这也会导致浏览器被锁死。

$.ajax函数返回他创建的XMLHttpRequest对象。通常JPlus只在内部处理并创建这个对象，但用户也可以通过xhr选项来传递一个自己创建的xhr对象。返回的对象通常已经被丢弃了，但依然提供一个底层接口来观察和操控请求。比如说，调用对象上的.abort()可以在请求完成前挂起请求。
</longdesc>
        <params name="options" type="Object" optional="true">
          <desc>AJAX 请求设置。所有选项都是可选的。</desc>
        </params>
        <option name="async" type="Boolean">
          <desc>(默认: true) 默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。</desc>
        </option>
        <option name="beforeSend(XHR)" type="Function">
          <desc>发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。XMLHttpRequest 对象是唯一的参数。这是一个 &lt;a href="http://docs.jquery.com/Ajax_Events" title="Ajax Events"&gt;Ajax 事件&lt;/a&gt;。如果返回false可以取消本次ajax请求。
&lt;pre&gt;function (XMLHttpRequest) {
    this; // 调用本次AJAX请求时传递的options参数
}&lt;/pre&gt;</desc>
        </option>
        <option name="cache" type="Boolean">
          <desc>(默认: true,dataType为script和jsonp时默认为false) JPlus 1.2 新功能，设置为 false 将不缓存此页面。</desc>
        </option>
        <option name="complete(XHR, TS)" type="Function">
          <desc>请求完成后回调函数 (请求成功或失败之后均调用)。参数：  XMLHttpRequest 对象和一个描述成功请求类型的字符串。 &lt;a href="http://docs.jquery.com/Ajax_Events" title="Ajax Events"&gt;Ajax 事件&lt;/a&gt;。
&lt;pre&gt;function (XMLHttpRequest, textStatus) {
    this; // 调用本次AJAX请求时传递的options参数
}&lt;/pre&gt;</desc>
        </option>
        <option name="contentType" type="String">
          <desc>(默认: "application/x-www-form-urlencoded") 发送信息至服务器时内容编码类型。默认值适合大多数情况。如果你明确地传递了一个content-type给 $.ajax() 那么他必定会发送给服务器（即使没有数据要发送）</desc>
        </option>
        <option name="context" type="Object">
          <desc>这个对象用于设置Ajax相关回调函数的上下文。也就是说，让回调函数内this指向这个对象（如果不设定这个参数，那么this就指向调用本次AJAX请求时传递的options参数）。比如指定一个DOM元素作为context参数，这样就设置了success回调函数的上下文为这个DOM元素。就像这样： &lt;pre&gt;$.ajax({ url: &quot;test.html&quot;, context: document.body, success: function(){
    $(this).addClass(&quot;done&quot;);
}});&lt;/pre&gt;</desc>
        </option>
        <option name="data" type="Object,String">
          <desc>发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，JPlus 将自动为不同值对应同一个名称。如 {foo:["bar1", "bar2"]} 转换为 '&amp;foo=bar1&amp;foo=bar2'。</desc>
        </option>
        <option name="dataFilter" type="Function">
          <desc>给Ajax返回的原始数据的进行预处理的函数。提供data和type两个参数：data是Ajax返回的原始数据，type是调用JPlus.ajax时提供的dataType参数。函数返回的值将由JPlus进一步处理。
&lt;pre&gt;function (data, type) {
    // 对Ajax返回的原始数据进行预处理
    return data  // 返回处理后的数据
}&lt;/pre&gt;</desc>
        </option>
        <option name="dataType" type="String">
          <desc>
            &lt;p&gt;预期服务器返回的数据类型。如果不指定，JPlus 将自动根据 HTTP 包 MIME 信息来智能判断，比如XML MIME类型就被识别为XML。在1.4中，JSON就会生成一个JavaScript对象，而script则会执行这个脚本。随后服务器端返回的数据会根据这个值解析后，传递给回调函数。可用值: &lt;/p&gt;
            &lt;p&gt;"xml": 返回 XML 文档，可用 JPlus 处理。&lt;/p&gt;
            &lt;p&gt;"html": 返回纯文本 HTML 信息；包含的script标签会在插入dom时执行。&lt;/p&gt;
            &lt;p&gt;"script": 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了"cache"参数。'''注意：'''在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(因为将使用DOM的script标签来加载)&lt;/p&gt;
            &lt;p&gt;"json": 返回 JSON 数据 。&lt;/p&gt;
            &lt;p&gt;"jsonp": &lt;a href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/" class="external text" title="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/"&gt;JSONP&lt;/a&gt; 格式。使用 &lt;a href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/" class="external text" title="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/"&gt;JSONP&lt;/a&gt; 形式调用函数时，如 "myurl?callback=?" JPlus 将自动替换 ? 为正确的函数名，以执行回调函数。&lt;/p&gt;
            &lt;p&gt;"text": 返回纯文本字符串&lt;/p&gt;
          </desc>
        </option>
        <option name="error" type="Function">
          <desc>(默认: 自动判断 (xml 或 html)) 请求失败时调用此函数。有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。如果发生了错误，错误信息（第二个参数）除了得到null之外，还可能是"timeout", "error", "notmodified" 和 "parsererror"。&lt;a href="http://docs.jquery.com/Ajax_Events" title="Ajax Events"&gt;Ajax 事件&lt;/a&gt;。
&lt;pre&gt;function (XMLHttpRequest, textStatus, errorThrown) {
    // 通常 textStatus 和 errorThrown 之中
    // 只有一个会包含信息
    this; // 调用本次AJAX请求时传递的options参数
}&lt;/pre&gt;</desc>
        </option>
        <option name="global" type="Boolean">
          <desc>(默认: true) 是否触发全局 AJAX 事件。设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 可用于控制不同的 &lt;a href="http://docs.jquery.com/Ajax_Events" title="Ajax Events"&gt;Ajax 事件&lt;/a&gt;。</desc>
        </option>
        <option name="ifModified" type="Boolean">
          <desc>(默认: false) 仅在服务器数据改变时获取新数据。使用 HTTP 包 Last-Modified 头信息判断。在JPlus 1.4中，他也会检查服务器指定的'etag'来确定数据没有被修改过。</desc>
        </option>
        <option name="jsonp" type="String">
          <desc>在一个jsonp请求中重写回调函数的名字。这个值用来替代在"callback=?"这种GET或POST请求中URL参数里的"callback"部分，比如{jsonp:'onJsonPLoad'}会导致将"onJsonPLoad=?"传给服务器。</desc>
        </option>
        <option name="jsonpCallback" type="String">
          <desc>为jsonp请求指定一个回调函数名。这个值将用来取代JPlus自动生成的随机函数名。这主要用来让JPlus生成度独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存GET请求的时候，指定这个回调函数名。</desc>
        </option>
        <option name="password" type="String">
          <desc>用于响应HTTP访问认证请求的密码</desc>
        </option>
        <option name="processData" type="Boolean">
          <desc>(默认: true) 默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 "application/x-www-form-urlencoded"。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。</desc>
        </option>
        <option name="scriptCharset" type="String">
          <desc>只有当请求时dataType为"jsonp"或"script"，并且type是"GET"才会用于强制修改charset。通常只在本地和远程的内容编码不同时使用。</desc>
        </option>
        <option name="success" type="Function">
          <desc>请求成功后的回调函数。参数：由服务器返回，并根据dataType参数进行处理后的数据；描述状态的字符串。 &lt;a href="http://docs.jquery.com/Ajax_Events" title="Ajax Events"&gt;Ajax 事件&lt;/a&gt;。
&lt;pre&gt;function (data, textStatus) {
    // data 可能是 xmlDoc, jsonObj, html, text, 等等...
    this; // 调用本次AJAX请求时传递的options参数
}&lt;/pre&gt;</desc>
        </option>
        <option name="traditional" type="Boolean">
          <desc>如果你想要用传统的方式来序列化数据，那么就设置为true。请参考工具分类下面的JPlus.param 方法。</desc>
        </option>
        <option name="timeout" type="Number">
          <desc>设置请求超时时间（毫秒）。此设置将覆盖全局设置。</desc>
        </option>
        <option name="type" type="String">
          <desc>(默认: "GET") 请求方式 ("POST" 或 "GET")， 默认为 "GET"。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。</desc>
        </option>
        <option name="url" type="String">
          <desc>(默认: 当前页地址) 发送请求的地址。</desc>
        </option>
        <option name="username" type="String">
          <desc>用于响应HTTP访问认证请求的用户名</desc>
        </option>
        <option name="xhr" type="Function">
          <desc>需要返回一个XMLHttpRequest 对象。默认在IE下是ActiveXObject 而其他情况下是XMLHttpRequest 。用于重写或者提供一个增强的XMLHttpRequest 对象。这个参数在JPlus 1.3以前不可用。</desc>
        </option>
        <example>
          <desc>加载并执行一个 JS 文件。</desc>
          <code>$.ajax({
  type: "GET",
  url: "test.js",
  dataType: "script"
});</code>
        </example>
        <example>
          <desc>保存数据到服务器，成功时显示信息。</desc>
          <code>$.ajax({
   type: "POST",
   url: "some.php",
   data: "name=John&amp;location=Boston",
   success: function(msg){
     alert( "Data Saved: " + msg );
   }
});</code>
        </example>
        <example>
          <desc>装入一个 HTML 网页最新版本。</desc>
          <code>$.ajax({
  url: "test.html",
  cache: false,
  success: function(html){
    $("#results").append(html);
  }
});</code>
        </example>
        <example>
          <desc>同步加载数据。发送请求时锁住浏览器。需要锁定用户交互操作时使用同步方式。</desc>
          <code> var html = $.ajax({
  url: "some.php",
  async: false
 }).responseText;</code>
        </example>
        <example>
          <desc>发送 XML 数据至服务器。设置 processData 选项为 false，防止自动转换数据格式。</desc>
          <code> var xmlDocument = [create xml document];
 $.ajax({
   url: "page.php",
   processData: false,
   data: xmlDocument,
   success: handleResponse
 });</code>
        </example>
      </function>
      <function name="load" return="JPlus">
        <desc>载入远程 HTML 文件代码并插入至 DOM 中。</desc>
        <longdesc>默认使用 GET 方式 - 传递附加参数时自动转换为 POST 方式。JPlus 1.2 中，可以指定选择符，来筛选载入的 HTML 文档，DOM 中将仅插入筛选出的 HTML 代码。语法形如 "url #some &gt; selector"。请查看示例。</longdesc>
        <params name="url" type="String">
          <desc>待装入 HTML 网页网址。</desc>
        </params>
        <params name="data" type="Map,String" optional="true">
          <desc>发送至服务器的 key/value 数据。在JPlus 1.3中也可以接受一个字符串了。</desc>
        </params>
        <params name="callback" type="Callback" optional="true">
          <desc>载入成功时回调函数。</desc>
        </params>
        <example>
          <desc>加载文章侧边栏导航部分至一个无序列表。</desc>
          <html>&lt;b&gt;JPlus Links:&lt;/b&gt;
&lt;ul id="links"&gt;&lt;/ul&gt;</html>
          <code>$("#links").load("/Main_Page #p-Getting-Started li");</code>
        </example>
        <example>
          <desc>加载 feeds.html 文件内容。</desc>
          <code>$("#feeds").load("feeds.html");</code>
        </example>
        <example>
          <desc>同上，但是以 POST 形式发送附加参数并在成功时显示信息。</desc>
          <code> $("#feeds").load("feeds.php", {limit: 25}, function(){
   alert("The last 25 entries in the feed have been loaded");
 });</code>
        </example>
      </function>
      <function name="JPlus.get" return="XMLHttpRequest">
        <desc>通过远程 HTTP GET 请求载入信息。</desc>
        <longdesc>这是一个简单的 GET 请求功能以取代复杂 $.ajax 。请求成功时可调用回调函数。如果需要在出错时执行函数，请使用 $.ajax。</longdesc>
        <params name="url" type="String">
          <desc>待载入页面的URL地址</desc>
        </params>
        <params name="data" type="Map" optional="true">
          <desc>待发送 Key/value 参数。</desc>
        </params>
        <params name="callback" type="Function" optional="true">
          <desc>载入成功时回调函数。</desc>
        </params>
        <params name="type" type="String" optional="true">
          <desc>返回内容格式，xml, html, script, json, text, _default。</desc>
        </params>
        <example>
          <desc>请求 test.php 网页，忽略返回值。</desc>
          <code>$.get("test.php");</code>
        </example>
        <example>
          <desc>请求 test.php 网页，传送2个参数，忽略返回值。</desc>
          <code>$.get("test.php", { name: "John", time: "2pm" } );</code>
        </example>
        <example>
          <desc>显示 test.php 返回值(HTML 或 XML，取决于返回值)。</desc>
          <code>$.get("test.php", function(data){
  alert("Data Loaded: " + data);
});</code>
        </example>
        <example>
          <desc>显示 test.cgi 返回值(HTML 或 XML，取决于返回值)，添加一组请求参数。</desc>
          <code>$.get("test.cgi", { name: "John", time: "2pm" },
  function(data){
    alert("Data Loaded: " + data);
  });</code>
        </example>
      </function>
      <function name="JPlus.getJSON" return="XMLHttpRequest">
        <desc>通过 HTTP GET 请求载入 JSON 数据。</desc>
        <longdesc>在 JPlus 1.2 中，您可以通过使用&lt;a href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/" class="external text" title="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/"&gt;JSONP&lt;/a&gt; 形式的回调函数来加载其他网域的JSON数据，如 "myurl?callback=?"。JPlus 将自动替换 ? 为正确的函数名，以执行回调函数。  注意：此行以后的代码将在这个回调函数执行前执行。</longdesc>
        <params name="url" type="String">
          <desc>发送请求地址。</desc>
        </params>
        <params name="data" type="Map" optional="true">
          <desc>待发送 Key/value 参数。</desc>
        </params>
        <params name="callback" type="Function" optional="true">
          <desc>载入成功时回调函数。</desc>
        </params>
        <example>
          <desc>从 Flickr JSONP API 载入 4 张最新的关于猫的图片。</desc>
          <html>&lt;div id="images"&gt;&lt;/div&gt;</html>
          <code>$.getJSON("http://api.flickr.com/services/feeds/photos_public.gne?tags=cat&amp;tagmode=any&amp;format=json&amp;jsoncallback=?", function(data){
  $.each(data.items, function(i,item){
    $("&lt;img/&gt;").attr("src", item.media.m).appendTo("#images");
    if ( i == 3 ) return false;
  });
});</code>
        </example>
        <example>
          <desc>从 test.js 载入 JSON 数据并显示 JSON 数据中一个 name 字段数据。</desc>
          <code>$.getJSON("test.js", function(json){
  alert("JSON Data: " + json.users[3].name);
});</code>
        </example>
        <example>
          <desc>从 test.js 载入 JSON 数据，附加参数，显示 JSON 数据中一个 name 字段数据。</desc>
          <code>$.getJSON("test.js", { name: "John", time: "2pm" }, function(json){
  alert("JSON Data: " + json.users[3].name);
});</code>
        </example>
      </function>
      <function name="JPlus.getScript" return="XMLHttpRequest">
        <desc>通过 HTTP GET 请求载入并执行一个 JavaScript 文件。</desc>
        <longdesc>JPlus 1.2 版本之前，getScript 只能调用同域 JS 文件。 1.2中，您可以跨域调用 JavaScript 文件。注意：Safari 2 或更早的版本不能在全局作用域中同步执行脚本。如果通过 getScript 加入脚本，请加入延时函数。</longdesc>
        <params name="url" type="String">
          <desc>待载入 JS 文件地址。</desc>
        </params>
        <params name="callback" type="Function" optional="true">
          <desc>成功载入后回调函数。</desc>
        </params>
        <example>
          <desc>载入 &lt;a title="http://jquery.com/plugins/project/color" class="external text" href="http://jquery.com/plugins/project/color"&gt;JPlus 官方颜色动画插件&lt;/a&gt; 成功后绑定颜色变化动画。</desc>
          <html>&lt;button id="go"&gt;» Run&lt;/button&gt;
&lt;div class="block"&gt;&lt;/div&gt;</html>
          <code>JPlus.getScript("http://dev.jquery.com/view/trunk/plugins/color/jquery.color.js", function(){
  $("#go").click(function(){
    $(".block").animate( { backgroundColor: 'pink' }, 1000)
      .animate( { backgroundColor: 'blue' }, 1000);
  });
});</code>
        </example>
        <example>
          <desc>加载并执行 test.js。</desc>
          <code>$.getScript("test.js");</code>
        </example>
        <example>
          <desc>加载并执行 test.js ，成功后显示信息。</desc>
          <code>$.getScript("test.js", function(){
  alert("Script loaded and executed.");
});</code>
        </example>
      </function>
      <function name="JPlus.post" return="XMLHttpRequest">
        <desc>通过远程 HTTP POST 请求载入信息。</desc>
        <longdesc>这是一个简单的 POST 请求功能以取代复杂 $.ajax 。请求成功时可调用回调函数。如果需要在出错时执行函数，请使用 $.ajax。</longdesc>
        <params name="url" type="String">
          <desc>发送请求地址。</desc>
        </params>
        <params name="data" type="Map" optional="true">
          <desc>待发送 Key/value 参数。</desc>
        </params>
        <params name="callback" type="Function" optional="true">
          <desc>发送成功时回调函数。</desc>
        </params>
        <params name="type" type="String" optional="true">
          <desc>返回内容格式，xml, html, script, json, text, _default。</desc>
        </params>
      </function>
    </subcat>
    <subcat value="Ajax 事件">
      <function name="ajaxComplete" return="JPlus">
        <desc>AJAX 请求完成时执行函数。Ajax 事件。</desc>
        <longdesc>XMLHttpRequest 对象和设置作为参数传递给回调函数。</longdesc>
        <params name="callback" type="Function">
          <desc>待执行函数</desc>
        </params>
        <example>
          <desc>AJAX 请求完成时执行函数。</desc>
          <code> $("#msg").ajaxComplete(function(event,request, settings){
   $(this).append("&lt;li&gt;请求完成.&lt;/li&gt;");
 });</code>
        </example>
      </function>
      <function name="ajaxError" return="JPlus">
        <desc>AJAX 请求发生错误时执行函数。Ajax 事件。</desc>
        <longdesc>XMLHttpRequest 对象和设置作为参数传递给回调函数。捕捉到的错误可作为最后一个参数传递。</longdesc>
        <params name="callback" type="Function">
          <desc>待执行函数
&lt;pre&gt;function (event, XMLHttpRequest, ajaxOptions, thrownError) {
      // thrownError 只有当异常发生时才会被传递
      this; // 监听的 dom 元素
}&lt;/pre&gt;</desc>
        </params>
        <example>
          <desc>AJAX 请求失败时显示信息。</desc>
          <code>$("#msg").ajaxError(function(event,request, settings){
     $(this).append("&lt;li&gt;出错页面:" + settings.url + "&lt;/li&gt;");
});</code>
        </example>
      </function>
      <function name="ajaxSend" return="JPlus">
        <desc>AJAX 请求发送前执行函数。Ajax 事件。</desc>
        <longdesc>XMLHttpRequest 对象和设置作为参数传递给回调函数。</longdesc>
        <params name="callback" type="Function">
          <desc>待执行函数</desc>
        </params>
        <example>
          <desc>AJAX 请求发送前显示信息。</desc>
          <code> $("#msg").ajaxSend(function(evt, request, settings){
   $(this).append("&lt;li&gt;开始请求: " + settings.url + "&lt;/li&gt;");
 });</code>
        </example>
      </function>
      <function name="ajaxStart" return="JPlus">
        <desc>AJAX 请求开始时执行函数。Ajax 事件。</desc>
        <params name="callback" type="Function">
          <desc>待执行函数</desc>
        </params>
        <example>
          <desc>AJAX 请求开始时显示信息。</desc>
          <code> $("#loading").ajaxStart(function(){
   $(this).show();
 });</code>
        </example>
      </function>
      <function name="ajaxStop" return="JPlus">
        <desc>AJAX 请求结束时执行函数。Ajax 事件。</desc>
        <params name="callback" type="Function">
          <desc>待执行函数</desc>
        </params>
        <example>
          <desc>AJAX 请求结束后隐藏信息。</desc>
          <code> $("#loading").ajaxStop(function(){
   $(this).hide();
 });</code>
        </example>
      </function>
      <function name="ajaxSuccess" return="JPlus">
        <desc>AJAX 请求成功时执行函数。Ajax 事件。</desc>
        <longdesc>XMLHttpRequest 对象和设置作为参数传递给回调函数。</longdesc>
        <params name="callback" type="Function">
          <desc>待执行函数</desc>
        </params>
        <example>
          <desc>当 AJAX 请求成功后显示消息。</desc>
          <code> $("#msg").ajaxSuccess(function(evt, request, settings){
   $(this).append("&lt;li&gt;请求成功!&lt;/li&gt;");
 });</code>
        </example>
      </function>
    </subcat>
    <subcat value="其它">
      <function name="JPlus.ajaxSetup" return="JPlus">
        <desc>设置全局 AJAX 默认选项。</desc>
        <longdesc>参数见 '$.ajax' 说明。</longdesc>
        <params name="options" type="Object" optional="true">
          <desc>选项设置。所有设置项均为可选设置。.</desc>
        </params>
        <example>
          <desc>设置 AJAX 请求默认地址为 "/xmlhttp/"，禁止触发全局 AJAX 事件，用 POST 代替默认 GET 方法。其后的 AJAX 请求不再设置任何选项参数。</desc>
          <code>$.ajaxSetup({
  url: "/xmlhttp/",
  global: false,
  type: "POST"
});
$.ajax({ data: myData });</code>
        </example>
      </function>
      <function name="serialize" return="String">
        <desc>序列表表格内容为字符串。</desc>
        <example>
          <desc>序列表表格内容为字符串，用于 Ajax 请求。</desc>
          <html>&lt;p id="results"&gt;&lt;b&gt;Results: &lt;/b&gt; &lt;/p&gt;
&lt;form&gt;
  &lt;select name="single"&gt;
    &lt;option&gt;Single&lt;/option&gt;
    &lt;option&gt;Single2&lt;/option&gt;
  &lt;/select&gt;
  &lt;select name="multiple" multiple="multiple"&gt;
    &lt;option selected="selected"&gt;Multiple&lt;/option&gt;
    &lt;option&gt;Multiple2&lt;/option&gt;
    &lt;option selected="selected"&gt;Multiple3&lt;/option&gt;
  &lt;/select&gt;&lt;br/&gt;
  &lt;input type="checkbox" name="check" value="check1"/&gt; check1
  &lt;input type="checkbox" name="check" value="check2" checked="checked"/&gt; check2
  &lt;input type="radio" name="radio" value="radio1" checked="checked"/&gt; radio1
  &lt;input type="radio" name="radio" value="radio2"/&gt; radio2
&lt;/form&gt;</html>
          <code>$("#results").append( "&lt;tt&gt;" + $("form").serialize() + "&lt;/tt&gt;" );</code>
        </example>
      </function>
      <function name="serializeArray" return="Array&lt;Object>">
        <desc>序列化表格元素 (类似 '.serialize()' 方法) 返回 JSON 数据结构数据。</desc>
        <longdesc>'''注意'''，此方法返回的是JSON对象而非JSON字符串。需要使用插件或者第三方库进行字符串化操作。

		返回的JSON对象是由一个对象数组组成的，其中每个对象包含一个或两个名值对——name参数和value参数（如果value不为空的话）。举例来说：
&lt;pre&gt;&lt;code&gt;  [ 
     {name: 'firstname', value: 'Hello'}, 
     {name: 'lastname', value: 'World'},
     {name: 'alias'}, // this one was empty
  ]
&lt;/code&gt;&lt;/pre&gt;
		</longdesc>
        <example>
          <desc>取得表单内容并插入到网页中。</desc>
          <html>&lt;p id="results"&gt;&lt;b&gt;Results:&lt;/b&gt; &lt;/p&gt;
&lt;form&gt;
  &lt;select name="single"&gt;
    &lt;option&gt;Single&lt;/option&gt;
    &lt;option&gt;Single2&lt;/option&gt;
  &lt;/select&gt;
  &lt;select name="multiple" multiple="multiple"&gt;
    &lt;option selected="selected"&gt;Multiple&lt;/option&gt;
    &lt;option&gt;Multiple2&lt;/option&gt;
    &lt;option selected="selected"&gt;Multiple3&lt;/option&gt;
  &lt;/select&gt;&lt;br/&gt;
  &lt;input type="checkbox" name="check" value="check1"/&gt; check1
  &lt;input type="checkbox" name="check" value="check2" checked="checked"/&gt; check2
  &lt;input type="radio" name="radio" value="radio1" checked="checked"/&gt; radio1
  &lt;input type="radio" name="radio" value="radio2"/&gt; radio2
&lt;/form&gt;</html>
          <code>var fields = $("select, :radio").serializeArray();
JPlus.each( fields, function(i, field){
  $("#results").append(field.value + " ");
});</code>
        </example>
      </function>
    </subcat>
  </cat>
  <cat value="工具">
    <subcat value="浏览器及特性检测">
      <property name="JPlus.support" return="Object">
        <desc>JPlus 1.3 新增。一组用于展示不同浏览器各自特性和bug的属性集合。</desc>
        <longdesc>JPlus提供了一系列属性，你也可以自由增加你自己的属性。其中许多属性是很低级的，所以很难说他们能否在日新月异的发展中一直保持有效，但这这些主要用于插件和内核开发者。

所有这些支持的属性值都通过特性检测来实现，而不是用任何浏览器检测。以下有一些非常棒的资源用于解释这些特性检测是如何工作的：&lt;ul&gt;&lt;li&gt;http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting&lt;/li&gt;&lt;li&gt;http://yura.thinkweb2.com/cft/&lt;/li&gt;&lt;li&gt;http://www.jibbering.com/faq/faq_notes/not_browser_detect.html&lt;/li&gt;&lt;/ul&gt;JPlus.support主要包括以下测试：

'''boxModel''': 如果这个页面和浏览器是以W3C CSS盒式模型来渲染的，则等于true。通常在IE 6和IE 7的怪癖模式中这个值是false。在document准备就绪前，这个值是null。

'''cssFloat''': 如果用cssFloat来访问CSS的float的值，则返回true。目前在IE中会返回false,他用styleFloat代替。

'''hrefNormalized''': 如果浏览器从getAttribute("href")返回的是原封不动的结果，则返回true。在IE中会返回false，因为他的URLs已经常规化了。

'''htmlSerialize''': 如果浏览器通过innerHTML插入链接元素的时候会序列化这些链接，则返回true，目前IE中返回false。

'''leadingWhitespace''': 如果在使用innerHTML的时候浏览器会保持前导空白字符，则返回true，目前在IE 6-8中返回false。

'''noCloneEvent''': 如果浏览器在克隆元素的时候不会连同事件处理函数一起复制，则返回true，目前在IE中返回false。

'''objectAll''': 如果在某个元素对象上执行getElementsByTagName("*")会返回所有子孙元素，则为true，目前在IE 7中为false。

'''opacity''': 如果浏览器能适当解释透明度样式属性，则返回true，目前在IE中返回false，因为他用alpha滤镜代替。

'''scriptEval''': 使用 appendChild/createTextNode 方法插入脚本代码时，浏览器是否执行脚本，目前在IE中返回false，IE使用 .text 方法插入脚本代码以执行。

'''style''': 如果getAttribute("style")返回元素的行内样式，则为true。目前IE中为false，因为他用cssText代替。

'''tbody''': 如果浏览器允许table元素不包含tbody元素，则返回true。目前在IE中会返回false，他会自动插入缺失的tbody。</longdesc>
        <example>
          <desc>检测浏览器是否支持盒式模型</desc>
          <code>JPlus.support.boxModel</code>
        </example>
      </property>
      <property name="JPlus.browser" return="Map">
        <desc>在JPlus 1.3中不建议使用。浏览器内核标识。依据 navigator.userAgent 判断。</desc>
        <longdesc>可用值:  safari 

 opera 

 msie 

 mozilla  此属性在 DOM 树加载完成前即有效，可用于为特定浏览器设置 ready 事件。 

浏览器对象检测技术与此属性共同使用可提供可靠的浏览器检测支持。</longdesc>
        <example>
          <desc>在 Microsoft's Internet Explorer 浏览器中返回 true。</desc>
          <code>$.browser.msie</code>
        </example>
        <example>
          <desc>仅在 Safari 中提示 "this is safari!" 。</desc>
          <code>if ($.browser.safari) {
   alert("this is safari!");
}</code>
        </example>
      </property>
      <property name="JPlus.browser.version" return="String">
        <desc>在JPlus 1.3中不建议使用。浏览器渲染引擎版本号。</desc>
        <longdesc>典型结果:  Internet Explorer: 6.0, 7.0 

 Mozilla/Firefox/Flock/Camino: 1.7.12, 1.8.1.3 

 Opera: 9.20 

 Safari/Webkit: 312.8, 418.9</longdesc>
        <example>
          <desc>显示当前 IE 浏览器版本号。</desc>
          <code>if ( $.browser.msie )
 alert( $.browser.version );</code>
        </example>
      </property>
      <property name="JPlus.boxModel" return="Boolean">
        <desc>在JPlus 1.3中不建议使用。当前页面中浏览器是否使用标准盒模型渲染页面。 建议使用 JPlus.support.boxModel 代替。W3C CSS 盒模型.</desc>
        <example>
          <desc>在 Internet Explorer 怪癖模式（QuirksMode）中返回 False。</desc>
          <code>$.boxModel</code>
        </example>
      </property>
    </subcat>
    <subcat value="数组和对象操作">
      <function name="JPlus.each" return="Object">
        <desc>通用例遍方法，可用于例遍对象和数组。</desc>
        <longdesc>不同于例遍 JPlus 对象的 $().each() 方法，此方法可用于例遍任何对象。回调函数拥有两个参数：第一个为对象的成员或数组的索引，第二个为对应变量或内容。如果需要退出 each 循环可使回调函数返回 false，其它返回值将被忽略。</longdesc>
        <params name="object" type="Object">
          <desc>需要例遍的对象或数组。</desc>
        </params>
        <params name="callback" type="Function" optional="true">
          <desc>每个成员/元素执行的回调函数。</desc>
        </params>
        <example>
          <desc>例遍数组，同时使用元素索引和内容。</desc>
          <code>$.each( [0,1,2], function(i, n){
  alert( "Item #" + i + ": " + n );
});</code>
        </example>
        <example>
          <desc>例遍对象，同时使用成员名称和变量内容。</desc>
          <code>$.each( { name: "John", lang: "JS" }, function(i, n){
  alert( "Name: " + i + ", Value: " + n );
});</code>
        </example>
      </function>
      <function name="JPlus.extend" return="Object">
        <desc>用一个或多个其他对象来扩展一个对象，返回被扩展的对象。</desc>
        <longdesc>如果不指定target，则给JPlus命名空间本身进行扩展。这有助于插件作者为JPlus增加新方法。
		
		如果第一个参数设置为true，则JPlus返回一个深层次的副本，递归地复制找到的任何对象。否则的话，副本会与原对象共享结构。
		
		未定义的属性将不会被复制，然而从对象的原型继承的属性将会被复制。</longdesc>
        <params name="deep" type="Object" optional="true">
          <desc>如果设为true，则递归合并。</desc>
        </params>
        <params name="target" type="Object">
          <desc>待修改对象。</desc>
        </params>
        <params name="object1" type="Object">
          <desc>待合并到第一个对象的对象。</desc>
        </params>
        <params name="objectN" type="Object" optional="true">
          <desc>待合并到第一个对象的对象。</desc>
        </params>
        <example>
          <desc>合并 settings 和 options，修改并返回 settings。</desc>
          <code>var settings = { validate: false, limit: 5, name: "foo" };
var options = { validate: true, name: "bar" };
JPlus.extend(settings, options);</code>
          <result>settings == { validate: true, limit: 5, name: "bar" }</result>
        </example>
        <example>
          <desc>合并 defaults 和 options, 不修改 defaults。</desc>
          <code>var empty = {};
var defaults = { validate: false, limit: 5, name: "foo" };
var options = { validate: true, name: "bar" };
var settings = JPlus.extend(empty, defaults, options);</code>
          <result>settings == { validate: true, limit: 5, name: "bar" }
empty == { validate: true, limit: 5, name: "bar" }</result>
        </example>
      </function>
      <function name="JPlus.grep" return="Array">
        <desc>使用过滤函数过滤数组元素。</desc>
        <longdesc>此函数至少传递两个参数：待过滤数组和过滤函数。过滤函数必须返回 true 以保留元素或 false 以删除元素。</longdesc>
        <params name="array" type="Array">
          <desc>待过滤数组。</desc>
        </params>
        <params name="callback" type="Function">
          <desc>此函数将处理数组每个元素。第一个参数为当前元素，第二个参数而元素索引值。此函数应返回一个布尔值。另外，此函数可设置为一个字符串，当设置为字符串时，将视为“lambda-form”（缩写形式？），其中 a 代表数组元素，i 代表元素索引值。如“a &gt; 0”代表“function(a){ return a &gt; 0; }”。</desc>
        </params>
        <params name="invert" type="Boolean" optional="true">
          <desc>如果 "invert" 为 false 或为设置，则函数返回数组中由过滤函数返回 true 的元素，当"invert" 为 true，则返回过滤函数中返回 false 的元素集。</desc>
        </params>
        <example>
          <desc>过滤数组中小于 0 的元素。</desc>
          <code>$.grep( [0,1,2], function(n,i){
  return n &gt; 0;
});</code>
          <result>[1, 2]</result>
        </example>
        <example>
          <desc>排除数组中大于 0 的元素，使用第三个参数进行排除。</desc>
          <code>$.grep( [0,1,2], function(n,i){
  return n &gt; 0;
}, true);</code>
          <result>[0]</result>
        </example>
      </function>
      <function name="JPlus.makeArray" return="Array">
        <desc>将类数组对象转换为数组对象。</desc>
        <longdesc>类数组对象有 length 属性，其成员索引为 0 至 length - 1。实际中此函数在 JPlus 中将自动使用而无需特意转换。</longdesc>
        <params name="obj" type="Object">
          <desc>类数组对象。</desc>
        </params>
        <example>
          <desc>过滤数组中小于 0 的元素。</desc>
          <html>&lt;div&gt;First&lt;/div&gt;&lt;div&gt;Second&lt;/div&gt;&lt;div&gt;Third&lt;/div&gt;&lt;div&gt;Fourth&lt;/div&gt;</html>
          <code>var arr = JPlus.makeArray(document.getElementsByTagName("div"));
arr.reverse(); // 使用数组翻转函数</code>
          <result>Fourth
Third
Second
First</result>
        </example>
      </function>
      <function name="JPlus.map" return="Array">
        <desc>将一个数组中的元素转换到另一个数组中。</desc>
        <longdesc>作为参数的转换函数会为每个数组元素调用，而且会给这个转换函数传递一个表示被转换的元素作为参数。转换函数可以返回转换后的值、null（删除数组中的项目）或一个包含值的数组，并扩展至原始数组中。</longdesc>
        <params name="array" type="Array">
          <desc>待转换数组。</desc>
        </params>
        <params name="callback" type="Function">
          <desc>为每个数组元素调用，而且会给这个转换函数传递一个表示被转换的元素作为参数。函数可返回任何值。另外，此函数可设置为一个字符串，当设置为字符串时，将视为“lambda-form”（缩写形式？），其中 a 代表数组元素。如“a * a”代表“function(a){ return a * a; }”。</desc>
        </params>
        <example>
          <desc>将原数组中每个元素加 4 转换为一个新数组。</desc>
          <code>$.map( [0,1,2], function(n){
  return n + 4;
});</code>
          <result>[4, 5, 6]</result>
        </example>
        <example>
          <desc>原数组中大于 0 的元素加 1 ，否则删除。</desc>
          <code>$.map( [0,1,2], function(n){
  return n &gt; 0 ? n + 1 : null;
});</code>
          <result>[2, 3]</result>
        </example>
        <example>
          <desc>原数组中每个元素扩展为一个包含其本身和其值加 1 的数组，并转换为一个新数组。</desc>
          <code>$.map( [0,1,2], function(n){
  return [ n, n + 1 ];
});</code>
          <result>[0, 1, 1, 2, 2, 3]</result>
        </example>
      </function>
      <function name="JPlus.inArray" return="Number">
        <desc>确定第一个参数在数组中的位置，从0开始计数(如果没有找到则返回 -1 )。</desc>
        <params name="value" type="Any">
          <desc>用于在数组中查找是否存在</desc>
        </params>
        <params name="array" type="Array">
          <desc>待处理数组。</desc>
        </params>
        <example>
          <desc>查看对应元素的位置</desc>
          <code>var arr = [ 4, "Pete", 8, "John" ];
JPlus.inArray("John", arr);  //3
JPlus.inArray(4, arr);  //0
JPlus.inArray("David", arr);  //-1</code>
        </example>
      </function>
      <function name="JPlus.toArray" return="Number">
        <desc>把JPlus集合中所有DOM元素恢复成一个数组。</desc>
        <example>
          <desc>得到所有li的元素数组</desc>
          <code>alert($('li').toArray());</code>
          <result>[&lt;li id=&quot;foo&quot;&gt;, &lt;li id=&quot;bar&quot;&gt;]</result>
        </example>
      </function>
      <function name="JPlus.merge" return="Array">
        <desc>合并两个数组</desc>
        <longdesc>返回的结果会修改第一个数组的内容——第一个数组的元素后面跟着第二个数组的元素。要去除重复项，请使用$.unique()</longdesc>
        <params name="first" type="Array">
          <desc>第一个待处理数组，会改变其中的元素。</desc>
        </params>
        <params name="second" type="Array">
          <desc>第二个待处理数组，不会改变其中的元素。</desc>
        </params>
        <example>
          <desc>合并两个数组到第一个数组上。</desc>
          <code>$.merge( [0,1,2], [2,3,4] )</code>
          <result>[0,1,2,2,3,4]</result>
        </example>
      </function>
      <function name="JPlus.unique" return="Array">
        <desc>删除数组中重复元素。只处理删除DOM元素数组，而不能处理字符串或者数字数组。</desc>
        <params name="array" type="Array">
          <desc>待处理数组。</desc>
        </params>
        <example>
          <desc>删除重复 div 标签。</desc>
          <code>$.unique(document.getElementsByTagName("div"));</code>
          <result>[&lt;div&gt;, &lt;div&gt;, ...]</result>
        </example>
      </function>
      <function name="JPlus.parseJSON" return="String">
        <desc>接受一个JSON字符串，返回解析后的对象。</desc>
		<longdesc>传入一个畸形的JSON字符串会抛出一个异常。比如下面的都是畸形的JSON字符串：
		
&lt;ul&gt;
	&lt;li&gt;{test: 1} （ test 没有包围双引号）&lt;/li&gt;
	&lt;li&gt;{'test': 1} （使用了单引号而不是双引号）&lt;/li&gt;
&lt;/ul&gt;

另外，如果你什么都不传入，或者一个空字符串、null或undefined，parseJSON都会返回 null 。
		</longdesc>
        <params name="json" type="String">
          <desc>要解析的JSON字符串</desc>
        </params>
        <example>
          <desc>解析一个JSON字符串</desc>
          <code>var obj = JPlus.parseJSON('{"name":"John"}');
alert( obj.name === "John" );</code>
        </example>
      </function>
    </subcat>
    <subcat value="函数操作">
      <property name="JPlus.noop" return="Array">
        <desc>一个空函数</desc>
		<longdesc>当你仅仅想要传递一个空函数的时候，就用他吧。这对一些插件作者很有用，当插件提供了一个可选的回调函数接口，那么如果调用的时候没有传递这个回调函数，就用JPlus.noop来代替执行。</longdesc>
      </property>
      <function name="JPlus.proxy" return="Boolean">
        <desc>JPlus 1.4 新增。返回一个新函数，并且这个函数始终保持了特定的作用域。</desc>
		<longdesc>当有事件处理函数要附加到元素上，但他们的作用域实际是指向另一个对象时，这个方法最有用了。此外，最妙的是，JPlus能够确保即便你绑定的函数是经过JPlus.proxy()处理过的函数，你依然可以传递原先的函数来准确无误地取消绑定。请参考下面的例子。
		
		这个函数还有另一种用法，JPlus.proxy( scope, name )。第一个参数是要设定的作用域对象。第二个参数是将要设置作用域的函数名（必须是第一个作用域对象的一个属性）。</longdesc>
        <params name="function" type="Function">
          <desc>将要被改变作用域的函数</desc>
        </params>
        <params name="scope" type="Object">
          <desc>一个object，那个函数的作用域会被设置到这个object上来。</desc>
        </params>
        <example>
          <desc>强制设置函数的作用域，让this指向obj而不是#test对象。</desc>
		  <html>&lt;div id=&quot;test&quot;&gt;Click Here!&lt;/div&gt;</html>
          <code>var obj = {
  name: "John",
  test: function() {
    alert( this.name );
    $("#test").unbind("click", obj.test);
  }
};

$("#test").click( JPlus.proxy( obj, "test" ) );

// 以下代码跟上面那句是等价的:
// $("#test").click( JPlus.proxy( obj.test, obj ) );

// 可以与单独执行下面这句做个比较。
// $("#test").click( obj.test );
</code>
        </example>
      </function>
    </subcat>
    <subcat value="测试操作">
      <function name="JPlus.contains" return="Boolean">
        <desc>JPlus 1.4 新增。一个DOM节点是否包含另一个DOM节点。</desc>
        <params name="container" type="Object">
          <desc>DOM元素作为容器，可以包含其他元素</desc>
        </params>
        <params name="contained" type="Object">
          <desc>DOM节点，可能被其他元素所包含</desc>
        </params>
        <example>
          <desc>检测一个元素是否包含另一个元素</desc>
          <code>JPlus.contains(document.documentElement, document.body); // true
JPlus.contains(document.body, document.documentElement); // false</code>
        </example>
      </function>
      <function name="JPlus.isArray" return="Boolean">
        <desc>JPlus 1.3 新增。测试对象是否为数组。</desc>
        <params name="obj" type="Object">
          <desc>用于测试是否为数组的对象</desc>
        </params>
        <example>
          <desc>检测是否为数组</desc>
          <code>$("b").append( " + $.isArray([]) );</code>
          <result>&lt;b&gt;true&lt;/b&gt;</result>
        </example>
      </function>
      <function name="JPlus.isFunction" return="Boolean">
        <desc>测试对象是否为函数。</desc>
        <longdesc>'''注意：'''JPlus 1.3以后，在IE浏览器里，浏览器提供的函数比如'alert'还有 DOM 元素的方法比如 'getAttribute' 将不认为是函数</longdesc>
        <params name="obj" type="Object">
          <desc>用于测试是否为函数的对象</desc>
        </params>
        <example>
          <desc>检测是否为函数</desc>
          <code>function stub() {
    }
var objs = [
            function () {},
            { x:15, y:20 },
            null,
            stub,
            "function"
          ];
        JPlus.each(objs, function (i) {
        var isFunc = JPlus.isFunction(objs[i]);
        $("span:eq( " + i + ")").text(isFunc);
      });</code>
          <result>[ true,false,false,true,false ]</result>
        </example>
      </function>
      <function name="JPlus.isEmptyObject" return="Boolean">
        <desc>JPlus 1.4 新增。测试对象是否是空对象（不包含任何属性）。</desc>
		<longdesc>JPlus 1.4 中，这个方法既检测对象本身的属性，也检测从原型继承的属性（因此没有使用hasOwnProperty）。</longdesc>
        <params name="obj" type="Object">
          <desc>用于测试是否为空对象</desc>
        </params>
        <example>
          <desc>测试是否为空对象</desc>
          <code>JPlus.isEmptyObject({}) // true
JPlus.isEmptyObject({ foo: "bar" }) // false</code>
        </example>
      </function>
      <function name="JPlus.isPlainObject" return="Boolean">
        <desc>JPlus 1.4 新增。测试对象是否是纯粹的对象（通过 "{}" 或者 "new Object" 创建的）。</desc>
        <params name="obj" type="Object">
          <desc>用于测试是否为纯粹的对象</desc>
        </params>
        <example>
          <desc>测试是否为纯粹的对象</desc>
          <code>JPlus.isPlainObject({}) // true
JPlus.isPlainObject("test") // false</code>
        </example>
      </function>
    </subcat>
    <subcat value="字符串操作">
      <function name="JPlus.trim" return="String">
        <desc>去掉字符串起始和结尾的空格。</desc>
        <params name="str" type="String">
          <desc>需要处理的字符串</desc>
        </params>
        <example>
          <desc>去掉字符串起始和结尾的空格。</desc>
          <code>$.trim("  hello, how are you?  ");</code>
          <result>"hello, how are you?"</result>
        </example>
      </function>
    </subcat>
    <subcat value="URL">
      <function name="JPlus.param" return="String">
        <desc>将表单元素数组或者对象序列化。是.serialize()的核心方法。</desc>
		<longdesc>在JPlus 1.3中，如果传递的参数是一个函数，那么用.param()会得到这个函数的返回值，而不是把这个函数作为一个字符串来返回。
		
		在JPlus 1.4中，.param()会深度递归一个对象来满足现在脚本语言和框架，比如PHP， Ruby on Rails等。你可以通过JPlus.ajaxSettings.traditional = true; 来全局得禁用这个功能。
		
		注意：因为有些框架在解析序列化数字的时候能力有限，所以当传递一些含有嵌套对象、数组的对象作为参数时，请务必小心！
		
		在JPlus 1.4中，HTML5的input元素也会被序列化。</longdesc>
        <params name="obj" type="Array&lt;Elements>, JPlus, Object">
          <desc>数组或JPlus对象会按照name/value对进行序列化，普通对象按照key/value对进行序列化。</desc>
        </params>
        <params name="traditional" type="Boolean" optional="True">
          <desc>是否使用传统的方式浅层序列化。</desc>
        </params>
        <example>
          <desc>按照key/value对序列化普通对象。</desc>
          <code>
    var params = { width:1680, height:1050 };
    var str = JPlus.param(params);
    $("#results").text(str);</code>
          <result>width=1680&amp;height=1050</result>
        </example>
        <example>
          <desc>对比两种序列化方式</desc>
          <code><![CDATA[var myObject = {
  a: {
    one: 1, 
    two: 2, 
    three: 3
  }, 
  b: [1,2,3]
};
var recursiveEncoded = $.param(myObject);
var recursiveDecoded = decodeURIComponent($.param(myObject));

alert(recursiveEncoded);
alert(recursiveDecoded);
//a%5Bone%5D=1&a%5Btwo%5D=2&a%5Bthree%5D=3&b%5B%5D=1&b%5B%5D=2&b%5B%5D=3
//a[one]=1&a[two]=2&a[three]=3&b[]=1&b[]=2&b[]=3

var shallowEncoded = $.param(myObject, true);
var shallowDecoded = decodeURIComponent(shallowEncoded);

alert(shallowEncoded);
alert(shallowDecoded);
//a=%5Bobject+Object%5D&b=1&b=2&b=3
//a=[object+Object]&b=1&b=2&b=3
]]></code>
        </example>
      </function>
    </subcat>
    <subcat value="插件编写">
      <function name="JPlus.error" return="String">
        <desc>接受一个字符串，并且直接抛出一个包含这个字符串的异常。</desc>
		<longdesc>这个方法的主要目的是提供给插件开发人员，让他们可以重载这个方法，并以更好的方式显示错误，或者提供更多信息。</longdesc>
        <params name="message" type="String">
          <desc>要抛出的消息</desc>
        </params>
        <example>
          <desc>重载JPlus.error，以便可以在Firebug里显示</desc>
          <code>JPlus.error = console.error;</code>
        </example>
      </function>
    </subcat>
  </cat>
  <cat value="关于">
    <subcat value="关于翻译">
      <selector name="aboutXMLDoc">
        <sample>关于JPlus 中文文档</sample>
        <longdesc><![CDATA[JPlus 文档XML文件内英文及代码部分版权归原官方wiki所有，中文部分分属<a href="http://www.cn-cuckoo.com/">为之漫笔</a>, <a href="http://shawphy.com">Shawphy</a> and <a href="http://cloudream.name">Cloudream</a>所有。欢迎转载、替换其他XSL样式或其他形式的转载，但必须保证XML文件原样转载，保留署名以及不可用于商业用途。本文档仅供参考，出于方便学习的目的而分发。使用者必须自行承担风险，因使用此文档造成的任何损失或者潜在的损失，译者均不为其负责。]]></longdesc>
      </selector>
      <selector name="aboutDoc1.3">
        <sample>关于JPlus 1.3 版翻译</sample>
        <longdesc><![CDATA[JPlus 1.3自从2009年1月14日发布后，后引来了各界的关注。我们也随即投入到翻译文档的工作中来。经过4天的努力，终于完工了。这个版本更新了不少东西，具体还请看<a href="changelog.txt">changelog</a>。感谢Cloudream的热情帮忙。这个版本还加入了检查更新的功能。如果有需要的同学可轻松查看是否有更新的中文文档(chm版中的检查更新也将同步升级)。-- <a href="http://shawphy.com">Shawphy</a>]]> 写于2009年1月18日</longdesc>
      </selector>
      <selector name="aboutDoc1.2">
        <sample>关于JPlus 1.2 版翻译</sample>
        <longdesc> <![CDATA[首先感谢 <a href="http://www.cn-cuckoo.com/">为之漫笔</a> 。他是1.1API的翻译者。1.2的翻译是完全基于1.1的API翻译的，拜一记。本次翻译临近结束时，由他翻译的Learning JPlus 的中文版《JPlus基础教程》即将出版。作为国内JPlus的引路人的他，我由衷地向他表示感谢！其次感谢 Ross Wan 写的这个仿Visiul JPlus的样式。本次翻译是基于他的英文版制作的。(由于GFW缘故，其博客请通过代理访问)最后感谢 <a href="http://cloudream.name">Cloudream</a> ,他也一起参与翻译了工具、原Dimensions插件和AJAX部分。并且加入了英文说明切换功能。断断续续翻译这个API有段时间了，虽然大部分都基于1.1的API复制过来，但也得校对以及跟官网的文档进行比较。所以也花了点时间。同时欢迎利用此版制作其他发行版以方便广大JPlus爱好者。转载请保留版权信息，谢谢。-- <a href="http://shawphy.com">Shawphy</a>]]></longdesc>
      </selector>
    </subcat>
    <subcat value="提交bug及获取更新">
      <selector name="bugAndUpdate">
        <sample>提交bug及获取更新</sample>
        <longdesc><![CDATA[<p>如果大家使用过程中发现了什么翻译错误，可以找到项目地址 <br /><a href="http://code.google.com/p/jquery-api-zh-cn/issues/list">http://code.google.com/p/jquery-api-zh-cn/issues/list</a><br />来反馈。  </p><h3>版本信息： </h3><p> $Rev$ <br /> $Author$ <br /> $Date$</p><p>changelog: <a href="changelog.txt">changelog.txt</a></p><h3>检查更新： </h3><div id="update">
						<button id="checkUpdate" onclick="window.curVer='100214';$('<script src=\'http://jquery-api-zh-cn.googlecode.com/svn/trunk/update.js?'+(+new Date)+'\' type=\'text/javascript\' charset=\'utf-8\'></script>').appendTo('head');">检查更新</button>
					</div>
]]></longdesc>
      </selector>
    </subcat>
  </cat>
</docs>

